; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30038.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?p0@@3UPoint@@A					; p0
_BSS	SEGMENT
?p0@@3UPoint@@A DQ 01H DUP (?)				; p0
_BSS	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0Cmathlibrary@@QEAA@XZ			; Cmathlibrary::Cmathlibrary
PUBLIC	?calc_convex_hull@Cmathlibrary@@QEAAHXZ		; Cmathlibrary::calc_convex_hull
PUBLIC	?nextToTop@Cmathlibrary@@AEAA?AUPoint@@AEAV?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@@Z ; Cmathlibrary::nextToTop
PUBLIC	?swap@Cmathlibrary@@AEAAXAEAUPoint@@0@Z		; Cmathlibrary::swap
PUBLIC	?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z	; Cmathlibrary::convexHull
PUBLIC	??4Cmathlibrary@@QEAAAEAV0@AEBV0@@Z		; Cmathlibrary::operator=
PUBLIC	??4Cmathlibrary@@QEAAAEAV0@$$QEAV0@@Z		; Cmathlibrary::operator=
PUBLIC	??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ ; std::deque<Point,std::allocator<Point> >::~deque<Point,std::allocator<Point> >
PUBLIC	?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ ; std::deque<Point,std::allocator<Point> >::_Xlen
PUBLIC	?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z ; std::deque<Point,std::allocator<Point> >::_Growmap
PUBLIC	?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::push
PUBLIC	??1?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::~stack<Point,std::deque<Point,std::allocator<Point> > >
PUBLIC	?distSq@@YAHUPoint@@0@Z				; distSq
PUBLIC	?orientation@@YAHUPoint@@00@Z			; orientation
PUBLIC	?compare@@YAHPEBX0@Z				; compare
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$uninitialized_copy@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@QEAPEAU1@0PEAPEAU1@@Z ; std::uninitialized_copy<Point * *,Point * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUPoint@@_K@std@@YAPEAPEAUPoint@@PEAPEAU1@_K@Z ; std::_Uninitialized_value_construct_n_unchecked1<Point * *,unsigned __int64>
PUBLIC	??$_Zero_range@PEAPEAUPoint@@@std@@YAPEAPEAUPoint@@QEAPEAU1@0@Z ; std::_Zero_range<Point * *>
PUBLIC	??$_Copy_memmove@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@00@Z ; std::_Copy_memmove<Point * *,Point * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5@				; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI@				; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@00000001000000010000000300000000
PUBLIC	__xmm@00000002000000010000000000000000
PUBLIC	__xmm@00000003000000030000000100000003
PUBLIC	__xmm@00000004000000040000000200000002
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__std_terminate:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp_qsort:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+66
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+60
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+60
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+66
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+43
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?calc_convex_hull@Cmathlibrary@@QEAAHXZ DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$?calc_convex_hull@Cmathlibrary@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?nextToTop@Cmathlibrary@@AEAA?AUPoint@@AEAV?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@@Z DD imagerel $LN59
	DD	imagerel $LN59+185
	DD	imagerel $unwind$?nextToTop@Cmathlibrary@@AEAA?AUPoint@@AEAV?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z DD imagerel $LN412
	DD	imagerel $LN412+1332
	DD	imagerel $unwind$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UPoint@@@std@@QEAAXQEAUPoint@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@UPoint@@@std@@QEAAXQEAUPoint@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UPoint@@@std@@QEAAPEAUPoint@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+112
	DD	imagerel $unwind$?allocate@?$allocator@UPoint@@@std@@QEAAPEAUPoint@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAUPoint@@@std@@QEAAXQEAPEAUPoint@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAUPoint@@@std@@QEAAXQEAPEAUPoint@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAUPoint@@@std@@QEAAPEAPEAUPoint@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+112
	DD	imagerel $unwind$?allocate@?$allocator@PEAUPoint@@@std@@QEAAPEAPEAUPoint@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ DD imagerel $LN46
	DD	imagerel $LN46+66
	DD	imagerel $unwind$??0?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ DD imagerel $LN93
	DD	imagerel $LN93+196
	DD	imagerel $unwind$??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAAAEAUPoint@@XZ DD imagerel $LN23
	DD	imagerel $LN23+56
	DD	imagerel $unwind$?back@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAAAEAUPoint@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAAXAEBUPoint@@@Z DD imagerel $LN42
	DD	imagerel $LN42+196
	DD	imagerel $unwind$?push_back@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAAXAEBUPoint@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD imagerel $LN150+73
	DD	imagerel $LN150+192
	DD	imagerel $chain$1$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD imagerel $LN150+192
	DD	imagerel $LN150+379
	DD	imagerel $chain$4$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD imagerel $LN150+379
	DD	imagerel $LN150+450
	DD	imagerel $chain$5$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD imagerel $LN150+450
	DD	imagerel $LN150+463
	DD	imagerel $chain$7$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD imagerel $LN150+463
	DD	imagerel $LN150+472
	DD	imagerel $chain$8$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAXXZ DD imagerel $LN65
	DD	imagerel $LN65+184
	DD	imagerel $unwind$?_Tidy@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+66
	DD	imagerel $unwind$??0?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?top@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAAEAUPoint@@XZ DD imagerel $LN25
	DD	imagerel $LN25+56
	DD	imagerel $unwind$?top@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAAEAUPoint@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z DD imagerel $LN45
	DD	imagerel $LN45+196
	DD	imagerel $unwind$?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@@YAHPEBX0@Z DD imagerel $LN13
	DD	imagerel $LN13+168
	DD	imagerel $unwind$?compare@@YAHPEBX0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN99
	DD	imagerel $LN99+457
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+108
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN37
	DD	imagerel $LN37+39
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN24
	DD	imagerel $LN24+122
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+61
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_internal@AEBUPoint@@@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAXAEBUPoint@@@Z DD imagerel $LN39
	DD	imagerel $LN39+196
	DD	imagerel $unwind$??$_Emplace_back_internal@AEBUPoint@@@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAXAEBUPoint@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN18
	DD	imagerel $LN18+53
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+37
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_copy@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@QEAPEAU1@0PEAPEAU1@@Z DD imagerel $LN20
	DD	imagerel $LN20+48
	DD	imagerel $unwind$??$uninitialized_copy@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@QEAPEAU1@0PEAPEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUPoint@@_K@std@@YAPEAPEAUPoint@@PEAPEAU1@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUPoint@@_K@std@@YAPEAPEAUPoint@@PEAPEAU1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+66
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_unchecked@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@QEAPEAU1@0@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Uninitialized_copy_unchecked@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@QEAPEAU1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAPEAUPoint@@@std@@YAPEAPEAUPoint@@QEAPEAU1@0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAPEAUPoint@@@std@@YAPEAPEAUPoint@@QEAPEAU1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@00@Z
pdata	ENDS
;	COMDAT __xmm@00000004000000040000000200000002
CONST	SEGMENT
__xmm@00000004000000040000000200000002 DB 02H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 04H, 00H, 00H, 00H, 04H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000030000000100000003
CONST	SEGMENT
__xmm@00000003000000030000000100000003 DB 03H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 03H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000002000000010000000000000000
CONST	SEGMENT
__xmm@00000002000000010000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 02H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000010000000300000000
CONST	SEGMENT
__xmm@00000001000000010000000300000000 DB 00H, 00H, 00H, 00H, 03H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAPEAUPoint@@@std@@YAPEAPEAUPoint@@QEAPEAU1@0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_unchecked@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@QEAPEAU1@0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUPoint@@_K@std@@YAPEAPEAUPoint@@PEAPEAU1@_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_copy@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@QEAPEAU1@0PEAPEAU1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_internal@AEBUPoint@@@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAXAEBUPoint@@@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 04H
	DB	'*'
	DB	00H
	DB	'<'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0eH
	DB	0e2H
	DB	00H
	DB	'T'
	DB	02H
	DB	0b6H
	DB	06H
	DB	0d8H
	DB	04H
	DB	'L'
	DB	0aH
	DB	'&'
	DB	0cH
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	091H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __std_terminate
	DB	02eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@@YAHPEBX0@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?top@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAAEAUPoint@@XZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	04f400H
	DD	0be400H
	DD	imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN150+73
	DD	imagerel $LN150+192
	DD	imagerel $chain$1$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD 061721H
	DD	0ac417H
	DD	09740eH
	DD	083405H
	DD	imagerel $LN150+73
	DD	imagerel $LN150+192
	DD	imagerel $chain$1$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD 041421H
	DD	04f414H
	DD	0be405H
	DD	imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	060034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAAXAEBUPoint@@@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAAAEAUPoint@@XZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAUPoint@@@std@@QEAAPEAPEAUPoint@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAUPoint@@@std@@QEAAXQEAPEAUPoint@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UPoint@@@std@@QEAAPEAUPoint@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UPoint@@@std@@QEAAXQEAUPoint@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z DB 06H
	DB	0dH, 05H
	DB	02H
	DB	'6'
	DB	04H
	DB	'a', 0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z DB 04H
	DB	0eH
	DD	imagerel __std_terminate
	DB	032H
	DD	imagerel ??1?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z
	DD	imagerel $ip2state$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z DD 0a1711H
	DD	0123417H
	DD	0f0109217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?nextToTop@Cmathlibrary@@AEAA?AUPoint@@AEAV?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?calc_convex_hull@Cmathlibrary@@QEAAHXZ DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@00@Z PROC ; std::_Copy_memmove<Point * *,Point * *>, COMDAT

; 4153 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8

; 4154 :     auto _FirstPtr              = _To_address(_First);
; 4155 :     auto _LastPtr               = _To_address(_Last);
; 4156 :     auto _DestPtr               = _To_address(_Dest);
; 4157 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4158 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4159 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4162 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 4164 :     } else {
; 4165 :         return _Dest + (_LastPtr - _FirstPtr);
; 4166 :     }
; 4167 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$_Copy_memmove@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@PEAPEAU1@00@Z ENDP ; std::_Copy_memmove<Point * *,Point * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$_Zero_range@PEAPEAUPoint@@@std@@YAPEAPEAUPoint@@QEAPEAU1@0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAPEAUPoint@@@std@@YAPEAPEAUPoint@@QEAPEAU1@0@Z PROC ; std::_Zero_range<Point * *>, COMDAT

; 1786 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1787 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1788 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00006	4c 8b c2	 mov	 r8, rdx
  00009	48 8b da	 mov	 rbx, rdx
  0000c	4c 2b c1	 sub	 r8, rcx
  0000f	33 d2		 xor	 edx, edx
  00011	e8 00 00 00 00	 call	 memset

; 1790 :     return _Last;

  00016	48 8b c3	 mov	 rax, rbx

; 1791 : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
??$_Zero_range@PEAPEAUPoint@@@std@@YAPEAPEAUPoint@@QEAPEAU1@0@Z ENDP ; std::_Zero_range<Point * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUPoint@@_K@std@@YAPEAPEAUPoint@@PEAPEAU1@_K@Z
_TEXT	SEGMENT
_UFirst$ = 48
_Count$ = 56
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUPoint@@_K@std@@YAPEAPEAUPoint@@PEAPEAU1@_K@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<Point * *,unsigned __int64>, COMDAT

; 1818 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1819 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1820 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1821 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1822 :         return _Zero_range(_UFirst, _UFirst + _Count);

  0000a	48 8d 1c d5 00
	00 00 00	 lea	 rbx, QWORD PTR [rdx*8]
  00012	48 8b f9	 mov	 rdi, rcx

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00015	4c 8b c3	 mov	 r8, rbx
  00018	33 d2		 xor	 edx, edx
  0001a	e8 00 00 00 00	 call	 memset

; 1819 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1820 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1821 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1822 :         return _Zero_range(_UFirst, _UFirst + _Count);

  0001f	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 1823 :     } else {
; 1824 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 1825 :         for (; 0 < _Count; --_Count) {
; 1826 :             _Backout._Emplace_back();
; 1827 :         }
; 1828 : 
; 1829 :         return _Backout._Release();
; 1830 :     }
; 1831 : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUPoint@@_K@std@@YAPEAPEAUPoint@@PEAPEAU1@_K@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<Point * *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$uninitialized_copy@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@QEAPEAU1@0PEAPEAU1@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$uninitialized_copy@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@QEAPEAU1@0PEAPEAU1@@Z PROC ; std::uninitialized_copy<Point * *,Point * *>, COMDAT

; 1680 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4162 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1688 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$uninitialized_copy@PEAPEAUPoint@@PEAPEAU1@@std@@YAPEAPEAUPoint@@QEAPEAU1@0PEAPEAU1@@Z ENDP ; std::uninitialized_copy<Point * *,Point * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00004	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

  00008	48 3b c1	 cmp	 rax, rcx
  0000b	76 28		 jbe	 SHORT $LN16@Allocate_m

; 85   :         return ::operator new(_Bytes);

  0000d	48 8b c8	 mov	 rcx, rax
  00010	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00015	48 8b c8	 mov	 rcx, rax

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00018	48 85 c0	 test	 rax, rax
  0001b	74 11		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0001d	48 83 c0 27	 add	 rax, 39			; 00000027H
  00021	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00025	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN7@Allocate_m:

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00034	cc		 int	 3
$LN16@Allocate_m:

; 138  :         _Throw_bad_array_new_length(); // add overflow

  00035	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0003a	cc		 int	 3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00009	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0000e	84 c0		 test	 al, al
  00010	75 0a		 jne	 SHORT $LN2@sentry

; 119  :                 this->_Myostr._Osfx();

  00012	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	90		 npad	 1
$LN2@sentry:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001c	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0001f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  00026	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  0002b	48 85 c9	 test	 rcx, rcx
  0002e	74 07		 je	 SHORT $LN10@sentry

; 81   :                 _Rdbuf->_Unlock();

  00030	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00033	ff 50 10	 call	 QWORD PTR [rax+16]
  00036	90		 npad	 1
$LN10@sentry:

; 120  :             }
; 121  :         }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00004	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00007	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  0000e	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	74 07		 je	 SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	ff 50 10	 call	 QWORD PTR [rax+16]
  0001e	90		 npad	 1
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 978  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 979  :     _Ostr.put(_Ostr.widen('\n'));

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	b2 0a		 mov	 dl, 10
  0000e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00012	48 03 cb	 add	 rcx, rbx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  0001b	0f b6 d0	 movzx	 edx, al
  0001e	48 8b cb	 mov	 rcx, rbx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 980  :     _Ostr.flush();

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 981  :     return _Ostr;

  00030	48 8b c3	 mov	 rax, rbx

; 982  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 734  :     const char* _Val) { // insert NTBS into char stream

$LN99:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	4c 8b fa	 mov	 r15, rdx
  00019	48 8b f1	 mov	 rsi, rcx

; 735  :     using _Elem = char;
; 736  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 737  : 
; 738  :     ios_base::iostate _State = ios_base::goodbit;

  0001c	33 db		 xor	 ebx, ebx
  0001e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	49 c7 c6 ff ff
	ff ff		 mov	 r14, -1
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL92@operator:
  00030	49 ff c6	 inc	 r14
  00033	42 38 1c 32	 cmp	 BYTE PTR [rdx+r14], bl
  00037	75 f7		 jne	 SHORT $LL92@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 363  :         return _Wide;

  00040	48 8b 7c 30 28	 mov	 rdi, QWORD PTR [rax+rsi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00045	48 85 ff	 test	 rdi, rdi
  00048	7e 0a		 jle	 SHORT $LN17@operator
  0004a	49 3b fe	 cmp	 rdi, r14
  0004d	7e 05		 jle	 SHORT $LN17@operator
  0004f	49 2b fe	 sub	 rdi, r14
  00052	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00054	33 ff		 xor	 edi, edi
$LN18@operator:

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00056	4c 8b e6	 mov	 r12, rsi
  00059	48 89 74 24 20	 mov	 QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  0005e	4c 8b 44 30 48	 mov	 r8, QWORD PTR [rax+rsi+72]
  00063	48 8b d1	 mov	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 73   :             if (_Rdbuf) {

  00066	4d 85 c0	 test	 r8, r8
  00069	74 0f		 je	 SHORT $LN39@operator

; 74   :                 _Rdbuf->_Lock();

  0006b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0006e	49 8b c8	 mov	 rcx, r8
  00071	ff 50 08	 call	 QWORD PTR [rax+8]
  00074	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00077	48 8b d1	 mov	 rdx, rcx
$LN39@operator:

; 93   :             if (!_Ostr.good()) {

  0007a	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0007e	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 93   :             if (!_Ostr.good()) {

  00083	74 04		 je	 SHORT $LN33@operator

; 94   :                 _Ok = false;

  00085	32 c0		 xor	 al, al

; 95   :                 return;

  00087	eb 2e		 jmp	 SHORT $LN95@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 70   :         return _Tiestr;

  00089	48 8b 44 30 50	 mov	 rax, QWORD PTR [rax+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0008e	48 85 c0	 test	 rax, rax
  00091	74 22		 je	 SHORT $LN35@operator
  00093	48 3b c6	 cmp	 rax, rsi
  00096	74 1d		 je	 SHORT $LN35@operator

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  :             _Tied->flush();

  00098	48 8b c8	 mov	 rcx, rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000a1	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000a4	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  000a8	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
  000ad	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000b0	48 8b d1	 mov	 rdx, rcx
  000b3	eb 02		 jmp	 SHORT $LN95@operator
$LN35@operator:

; 100  :                 _Ok = true;

  000b5	b0 01		 mov	 al, 1
$LN95@operator:

; 106  :         }

  000b7	88 44 24 28	 mov	 BYTE PTR _Ok$[rsp+8], al

; 741  :     const typename _Myos::sentry _Ok(_Ostr);
; 742  : 
; 743  :     if (!_Ok) {

  000bb	84 c0		 test	 al, al
  000bd	75 0a		 jne	 SHORT $LN8@operator

; 744  :         _State |= ios_base::badbit;

  000bf	bb 04 00 00 00	 mov	 ebx, 4

; 745  :     } else { // state okay, insert

  000c4	e9 a9 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000c9	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 326  :         return _Fmtfl;

  000cd	8b 4c 30 18	 mov	 ecx, DWORD PTR [rax+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000d1	81 e1 c0 01 00
	00		 and	 ecx, 448		; 000001c0H
  000d7	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000da	74 2d		 je	 SHORT $LN87@operator
  000dc	0f 1f 40 00	 npad	 4
$LL4@operator:

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000e0	48 85 ff	 test	 rdi, rdi
  000e3	7e 21		 jle	 SHORT $LN89@operator

; 749  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000e5	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000e8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000ec	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000f1	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000fc	83 f8 ff	 cmp	 eax, -1
  000ff	74 48		 je	 SHORT $LN96@operator

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00101	48 ff cf	 dec	 rdi
  00104	eb da		 jmp	 SHORT $LL4@operator
$LN89@operator:

; 750  :                     _State |= ios_base::badbit; // insertion failed, quit
; 751  :                     break;
; 752  :                 }
; 753  :             }
; 754  :         }
; 755  : 
; 756  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00106	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN87@operator:
  00109	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  0010d	4d 8b c6	 mov	 r8, r14
  00110	49 8b d7	 mov	 rdx, r15
  00113	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  0011e	49 3b c6	 cmp	 rax, r14
  00121	75 26		 jne	 SHORT $LN96@operator
$LL93@operator:

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00123	48 85 ff	 test	 rdi, rdi
  00126	7e 2a		 jle	 SHORT $LN6@operator

; 762  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00128	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0012b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012f	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00134	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	74 05		 je	 SHORT $LN96@operator

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00144	48 ff cf	 dec	 rdi
  00147	eb da		 jmp	 SHORT $LL93@operator
$LN96@operator:

; 763  :                     _State |= ios_base::badbit; // insertion failed, quit
; 764  :                     break;
; 765  :                 }
; 766  :             }
; 767  :         }
; 768  : 
; 769  :         _Ostr.width(0);

  00149	bb 04 00 00 00	 mov	 ebx, 4
  0014e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
$LN6@operator:
  00152	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00155	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00159	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
  00162	eb 0e		 jmp	 SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
  00164	48 8b 74 24 60	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00169	8b 5c 24 70	 mov	 ebx, DWORD PTR _State$[rsp]
  0016d	4c 8b 64 24 20	 mov	 r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 773  :     _Ostr.setstate(_State);

  00172	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00175	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00179	48 03 ce	 add	 rcx, rsi
  0017c	45 33 c0	 xor	 r8d, r8d
  0017f	8b d3		 mov	 edx, ebx
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00187	90		 npad	 1

; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00188	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0018d	84 c0		 test	 al, al
  0018f	75 0a		 jne	 SHORT $LN72@operator

; 119  :                 this->_Myostr._Osfx();

  00191	49 8b cc	 mov	 rcx, r12
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0019a	90		 npad	 1
$LN72@operator:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0019b	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0019f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  001a3	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  001a8	48 85 c9	 test	 rcx, rcx
  001ab	74 07		 je	 SHORT $LN76@operator

; 81   :                 _Rdbuf->_Unlock();

  001ad	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b0	ff 50 10	 call	 QWORD PTR [rax+16]
  001b3	90		 npad	 1
$LN76@operator:

; 774  :     return _Ostr;

  001b4	48 8b c6	 mov	 rax, rsi

; 775  : }

  001b7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c0	41 5f		 pop	 r15
  001c2	41 5e		 pop	 r14
  001c4	41 5c		 pop	 r12
  001c6	5f		 pop	 rdi
  001c7	5e		 pop	 rsi
  001c8	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
;	COMDAT ?compare@@YAHPEBX0@Z
_TEXT	SEGMENT
vp1$ = 8
vp2$ = 16
?compare@@YAHPEBX0@Z PROC				; compare, COMDAT

; 60   : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 61   :   Point* p1 = (Point*)vp1;
; 62   :   Point* p2 = (Point*)vp2;
; 63   : 
; 64   :   // Find orientation
; 65   :   int o = orientation(p0, *p1, *p2);

  0000a	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  0000d	48 8b 3a	 mov	 rdi, QWORD PTR [rdx]
  00010	4c 8b d3	 mov	 r10, rbx
  00013	44 8b 05 04 00
	00 00		 mov	 r8d, DWORD PTR ?p0@@3UPoint@@A+4

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  0001a	8b c7		 mov	 eax, edi

; 61   :   Point* p1 = (Point*)vp1;
; 62   :   Point* p2 = (Point*)vp2;
; 63   : 
; 64   :   // Find orientation
; 65   :   int o = orientation(p0, *p1, *p2);

  0001c	49 c1 ea 20	 shr	 r10, 32			; 00000020H

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  00020	2b c3		 sub	 eax, ebx

; 61   :   Point* p1 = (Point*)vp1;
; 62   :   Point* p2 = (Point*)vp2;
; 63   : 
; 64   :   // Find orientation
; 65   :   int o = orientation(p0, *p1, *p2);

  00022	45 8b ca	 mov	 r9d, r10d
  00025	4c 8b df	 mov	 r11, rdi
  00028	45 2b c8	 sub	 r9d, r8d
  0002b	49 c1 eb 20	 shr	 r11, 32			; 00000020H

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  0002f	44 0f af c8	 imul	 r9d, eax
  00033	8b d3		 mov	 edx, ebx
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?p0@@3UPoint@@A ; p0
  0003c	41 8b cb	 mov	 ecx, r11d
  0003f	2b d0		 sub	 edx, eax
  00041	41 2b ca	 sub	 ecx, r10d
  00044	0f af d1	 imul	 edx, ecx
  00047	44 2b ca	 sub	 r9d, edx

; 51   :     (q.x - p.x) * (r.y - q.y);
; 52   : 
; 53   :   if (val == 0) return 0;  // colinear

  0004a	75 3f		 jne	 SHORT $LN2@compare

; 39   :   return (p1.x - p2.x) * (p1.x - p2.x) +

  0004c	8b d0		 mov	 edx, eax
  0004e	41 8b c8	 mov	 ecx, r8d
  00051	41 2b ca	 sub	 ecx, r10d
  00054	2b c7		 sub	 eax, edi
  00056	0f af c9	 imul	 ecx, ecx
  00059	2b d3		 sub	 edx, ebx
  0005b	45 2b c3	 sub	 r8d, r11d
  0005e	0f af c0	 imul	 eax, eax
  00061	45 0f af c0	 imul	 r8d, r8d
  00065	0f af d2	 imul	 edx, edx
  00068	41 03 c0	 add	 eax, r8d

; 66   :   if (o == 0)
; 67   :     return (distSq(p0, *p2) >= distSq(p0, *p1)) ? -1 : 1;

  0006b	41 b8 ff ff ff
	ff		 mov	 r8d, -1

; 39   :   return (p1.x - p2.x) * (p1.x - p2.x) +

  00071	03 d1		 add	 edx, ecx

; 66   :   if (o == 0)
; 67   :     return (distSq(p0, *p2) >= distSq(p0, *p1)) ? -1 : 1;

  00073	b9 01 00 00 00	 mov	 ecx, 1
  00078	3b c2		 cmp	 eax, edx
  0007a	41 0f 4d c8	 cmovge	 ecx, r8d
  0007e	8b c1		 mov	 eax, ecx

; 68   : 
; 69   :   return (o == 2) ? -1 : 1;
; 70   : }

  00080	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00085	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  0008a	c3		 ret	 0
$LN2@compare:
  0008b	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00090	45 85 c9	 test	 r9d, r9d
  00093	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  000a3	41 0f 4e c0	 cmovle	 eax, r8d
  000a7	c3		 ret	 0
?compare@@YAHPEBX0@Z ENDP				; compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
;	COMDAT ?orientation@@YAHUPoint@@00@Z
_TEXT	SEGMENT
p$ = 8
q$ = 16
r$ = 24
?orientation@@YAHUPoint@@00@Z PROC			; orientation, COMDAT

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  00000	4d 8b c8	 mov	 r9, r8
  00003	4c 8b d2	 mov	 r10, rdx
  00006	49 c1 ea 20	 shr	 r10, 32			; 00000020H
  0000a	44 2b c2	 sub	 r8d, edx
  0000d	49 c1 e9 20	 shr	 r9, 32			; 00000020H
  00011	8b c2		 mov	 eax, edx
  00013	45 2b ca	 sub	 r9d, r10d
  00016	2b c1		 sub	 eax, ecx
  00018	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  0001c	44 2b d1	 sub	 r10d, ecx
  0001f	44 0f af c8	 imul	 r9d, eax
  00023	45 0f af d0	 imul	 r10d, r8d
  00027	45 2b d1	 sub	 r10d, r9d

; 51   :     (q.x - p.x) * (r.y - q.y);
; 52   : 
; 53   :   if (val == 0) return 0;  // colinear

  0002a	75 03		 jne	 SHORT $LN2@orientatio
  0002c	33 c0		 xor	 eax, eax

; 55   : }

  0002e	c3		 ret	 0
$LN2@orientatio:

; 54   :   return (val > 0) ? 1 : 2; // clock or counterclock wise

  0002f	33 c0		 xor	 eax, eax
  00031	45 85 d2	 test	 r10d, r10d
  00034	0f 9e c0	 setle	 al
  00037	ff c0		 inc	 eax

; 55   : }

  00039	c3		 ret	 0
?orientation@@YAHUPoint@@00@Z ENDP			; orientation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
;	COMDAT ?distSq@@YAHUPoint@@0@Z
_TEXT	SEGMENT
p1$ = 8
p2$ = 16
?distSq@@YAHUPoint@@0@Z PROC				; distSq, COMDAT

; 39   :   return (p1.x - p2.x) * (p1.x - p2.x) +

  00000	4c 8b c1	 mov	 r8, rcx
  00003	48 8b c2	 mov	 rax, rdx
  00006	49 c1 e8 20	 shr	 r8, 32			; 00000020H
  0000a	2b ca		 sub	 ecx, edx
  0000c	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00010	44 2b c0	 sub	 r8d, eax
  00013	0f af c9	 imul	 ecx, ecx
  00016	45 0f af c0	 imul	 r8d, r8d
  0001a	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]

; 40   :     (p1.y - p2.y) * (p1.y - p2.y);
; 41   : }

  0001e	c3		 ret	 0
?distSq@@YAHUPoint@@0@Z ENDP				; distSq
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ PROC ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::~stack<Point,std::deque<Point,std::allocator<Point> > >, COMDAT
  00000	e9 00 00 00 00	 jmp	 ??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ ; std::deque<Point,std::allocator<Point> >::~deque<Point,std::allocator<Point> >
??1?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::~stack<Point,std::deque<Point,std::allocator<Point> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\stack
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\stack
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\stack
;	COMDAT ?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z PROC ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::push, COMDAT

; 76   :     void push(const value_type& _Val) {

$LN45:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b d9	 mov	 rbx, rcx
  00018	4c 8b f2	 mov	 r14, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  0001b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0001f	4c 8b c9	 mov	 r9, rcx
  00022	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  00026	42 8d 04 01	 lea	 eax, DWORD PTR [rcx+r8]
  0002a	a8 01		 test	 al, 1
  0002c	75 22		 jne	 SHORT $LN6@push
  0002e	48 8d 41 02	 lea	 rax, QWORD PTR [rcx+2]
  00032	48 d1 e8	 shr	 rax, 1
  00035	48 39 43 10	 cmp	 QWORD PTR [rbx+16], rax
  00039	77 15		 ja	 SHORT $LN6@push

; 1114 :             _Growmap(1);

  0003b	ba 01 00 00 00	 mov	 edx, 1
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 ?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z ; std::deque<Point,std::allocator<Point> >::_Growmap
  00048	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  0004c	4c 8b 4b 20	 mov	 r9, QWORD PTR [rbx+32]
$LN6@push:

; 1115 :         }
; 1116 :         _Myoff() &= _Mapsize() * _Block_size - 1;

  00050	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00054	48 8d 04 4d ff
	ff ff ff	 lea	 rax, QWORD PTR [rcx*2-1]
  0005c	49 23 c0	 and	 rax, r8
  0005f	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  00063	48 ff c9	 dec	 rcx

; 1117 :         size_type _Newoff = _Myoff() + _Mysize();

  00066	4a 8d 3c 08	 lea	 rdi, QWORD PTR [rax+r9]

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  0006a	48 8b c7	 mov	 rax, rdi
  0006d	48 d1 e8	 shr	 rax, 1
  00070	48 23 c8	 and	 rcx, rax

; 1119 :         if (_Map()[_Block] == nullptr) {

  00073	48 8d 34 cd 00
	00 00 00	 lea	 rsi, QWORD PTR [rcx*8]
  0007b	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0007f	48 83 3c 31 00	 cmp	 QWORD PTR [rcx+rsi], 0
  00084	75 16		 jne	 SHORT $LN7@push
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00086	b9 10 00 00 00	 mov	 ecx, 16
  0008b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1120 :             _Map()[_Block] = _Getal().allocate(_Block_size);

  00090	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00094	48 89 04 0e	 mov	 QWORD PTR [rsi+rcx], rax
  00098	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
$LN7@push:

; 1123 :         _Alty_traits::construct(

  0009c	48 8b 0c 0e	 mov	 rcx, QWORD PTR [rsi+rcx]
  000a0	83 e7 01	 and	 edi, 1
  000a3	49 8b 06	 mov	 rax, QWORD PTR [r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\stack

; 78   :     }

  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1123 :         _Alty_traits::construct(

  000ab	48 89 04 f9	 mov	 QWORD PTR [rcx+rdi*8], rax

; 1124 :             _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), _STD forward<_Tys>(_Vals)...);
; 1125 : 
; 1126 :         ++_Mysize();

  000af	48 ff 43 20	 inc	 QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\stack

; 78   :     }

  000b3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000bd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c1	41 5e		 pop	 r14
  000c3	c3		 ret	 0
?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z ENDP ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
;	COMDAT ?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z PROC ; std::deque<Point,std::allocator<Point> >::_Growmap, COMDAT

; 1439 :     void _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2

$LN150:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1440 :         static_assert(1 < _Minimum_map_size, "The _Xlen() test should always be performed.");
; 1441 : 
; 1442 :         _Alpty _Almap(_Getal());
; 1443 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  00007	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  0000b	b8 01 00 00 00	 mov	 eax, 1
  00010	4d 85 c0	 test	 r8, r8
  00013	48 8b e9	 mov	 rbp, rcx
  00016	49 b9 ff ff ff
	ff ff ff ff 0f	 mov	 r9, 1152921504606846975	; 0fffffffffffffffH
  00020	49 0f 45 c0	 cmovne	 rax, r8
$LL2@Growmap:

; 1444 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _Minimum_map_size) {

  00024	48 8b f0	 mov	 rsi, rax
  00027	49 2b f0	 sub	 rsi, r8
  0002a	48 3b f2	 cmp	 rsi, rdx
  0002d	72 06		 jb	 SHORT $LN4@Growmap
  0002f	48 83 f8 08	 cmp	 rax, 8
  00033	73 14		 jae	 SHORT $LN3@Growmap
$LN4@Growmap:

; 1445 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1446 :             if (max_size() / _Block_size - _Newsize < _Newsize) {

  00035	49 8b c9	 mov	 rcx, r9
  00038	48 2b c8	 sub	 rcx, rax
  0003b	48 3b c8	 cmp	 rcx, rax
  0003e	0f 82 8b 01 00
	00		 jb	 $LN138@Growmap

; 1448 :             }
; 1449 : 
; 1450 :             _Newsize *= 2;

  00044	48 03 c0	 add	 rax, rax

; 1451 :         }

  00047	eb db		 jmp	 SHORT $LL2@Growmap
$LN3@Growmap:
  00049	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  0004e	48 b9 ff ff ff
	ff ff ff ff 1f	 mov	 rcx, 2305843009213693951 ; 1fffffffffffffffH
  00058	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1454 :         size_type _Myboff = _Myoff() / _Block_size;

  0005d	4c 8b 7d 18	 mov	 r15, QWORD PTR [rbp+24]
  00061	49 d1 ef	 shr	 r15, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00064	48 3b c1	 cmp	 rax, rcx
  00067	0f 87 5c 01 00
	00		 ja	 $LN142@Growmap

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  0006d	48 8d 0c c5 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00075	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0007c	72 2c		 jb	 SHORT $LN19@Growmap

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0007e	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

  00082	48 3b c1	 cmp	 rax, rcx
  00085	0f 86 3e 01 00
	00		 jbe	 $LN142@Growmap

; 85   :         return ::operator new(_Bytes);

  0008b	48 8b c8	 mov	 rcx, rax
  0008e	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00093	48 85 c0	 test	 rax, rax
  00096	0f 84 26 01 00
	00		 je	 $LN130@Growmap

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0009c	4c 8d 70 27	 lea	 r14, QWORD PTR [rax+39]
  000a0	49 83 e6 e0	 and	 r14, -32		; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000a4	49 89 46 f8	 mov	 QWORD PTR [r14-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a8	eb 12		 jmp	 SHORT $LN18@Growmap
$LN19@Growmap:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000aa	48 85 c9	 test	 rcx, rcx
  000ad	74 0a		 je	 SHORT $LN20@Growmap

; 85   :         return ::operator new(_Bytes);

  000af	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000b4	4c 8b f0	 mov	 r14, rax

; 244  :         return _Traits::_Allocate(_Bytes);

  000b7	eb 03		 jmp	 SHORT $LN18@Growmap
$LN20@Growmap:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000b9	45 33 f6	 xor	 r14d, r14d
$LN18@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1458 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  000bc	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  000c0	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000c5	48 8b 5d 10	 mov	 rbx, QWORD PTR [rbp+16]
  000c9	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  000ce	48 c1 e3 03	 shl	 rbx, 3
  000d2	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000d7	4e 8d 24 fd 00
	00 00 00	 lea	 r12, QWORD PTR [r15*8]
  000df	4a 8d 14 20	 lea	 rdx, QWORD PTR [rax+r12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000e3	48 2b da	 sub	 rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1456 :         _Mapptr _Myptr    = _Newmap + _Myboff;

  000e6	4b 8d 3c 34	 lea	 rdi, QWORD PTR [r12+r14]

; 1458 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  000ea	48 03 d8	 add	 rbx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ed	48 8b cf	 mov	 rcx, rdi
  000f0	4c 8b c3	 mov	 r8, rbx
  000f3	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1458 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  000f8	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  000fc	48 03 df	 add	 rbx, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1459 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

  000ff	48 8b cb	 mov	 rcx, rbx
  00102	4c 3b fe	 cmp	 r15, rsi
  00105	77 25		 ja	 SHORT $LN6@Growmap
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00107	4d 8b c4	 mov	 r8, r12
  0010a	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0010f	4c 8b c6	 mov	 r8, rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00112	49 8d 0c 1c	 lea	 rcx, QWORD PTR [r12+rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00116	4d 2b c7	 sub	 r8, r15
  00119	33 d2		 xor	 edx, edx
  0011b	49 c1 e0 03	 shl	 r8, 3
  0011f	e8 00 00 00 00	 call	 memset
  00124	4d 8b c4	 mov	 r8, r12
  00127	49 8b ce	 mov	 rcx, r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1463 :         } else { // increment not greater than offset of initial block

  0012a	eb 30		 jmp	 SHORT $LN147@Growmap
$LN6@Growmap:

; 1464 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

  0012c	48 8d 3c f5 00
	00 00 00	 lea	 rdi, QWORD PTR [rsi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00134	4c 8b c7	 mov	 r8, rdi
  00137	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1465 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  0013c	48 8b 5d 08	 mov	 rbx, QWORD PTR [rbp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00140	49 8b ce	 mov	 rcx, r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1465 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  00143	48 8d 14 1f	 lea	 rdx, QWORD PTR [rdi+rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00147	48 2b da	 sub	 rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1465 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  0014a	49 03 dc	 add	 rbx, r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0014d	4c 8b c3	 mov	 r8, rbx
  00150	e8 00 00 00 00	 call	 memmove

; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00155	4a 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00159	4c 8b c7	 mov	 r8, rdi
$LN147@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1470 :         if (_Map() != _Mapptr()) {

  0015c	33 d2		 xor	 edx, edx
  0015e	e8 00 00 00 00	 call	 memset
  00163	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00167	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  0016c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00171	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00176	48 85 c9	 test	 rcx, rcx
  00179	74 2e		 je	 SHORT $LN123@Growmap
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0017b	48 8b 55 10	 mov	 rdx, QWORD PTR [rbp+16]
  0017f	48 c1 e2 03	 shl	 rdx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00183	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0018a	72 18		 jb	 SHORT $LN133@Growmap

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0018c	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00190	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00194	49 2b c8	 sub	 rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00197	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0019b	48 83 f8 1f	 cmp	 rax, 31
  0019f	77 21		 ja	 SHORT $LN130@Growmap

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a1	49 8b c8	 mov	 rcx, r8
$LN133@Growmap:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001a4	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN123@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1475 :         _Mapsize() += _Count;

  001a9	48 01 75 10	 add	 QWORD PTR [rbp+16], rsi
  001ad	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  001b2	4c 89 75 08	 mov	 QWORD PTR [rbp+8], r14
  001b6	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 1476 :     }

  001bb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001bf	5e		 pop	 rsi
  001c0	5d		 pop	 rbp
  001c1	c3		 ret	 0
$LN130@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001c8	cc		 int	 3
$LN142@Growmap:

; 138  :         _Throw_bad_array_new_length(); // add overflow

  001c9	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  001ce	cc		 int	 3
$LN138@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1447 :                 _Xlen(); // result too long

  001cf	48 8b cd	 mov	 rcx, rbp
  001d2	e8 00 00 00 00	 call	 ?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ ; std::deque<Point,std::allocator<Point> >::_Xlen
  001d7	cc		 int	 3
$LN146@Growmap:
?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z ENDP ; std::deque<Point,std::allocator<Point> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
;	COMDAT ?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ PROC ; std::deque<Point,std::allocator<Point> >::_Xlen, COMDAT

; 1431 :     [[noreturn]] void _Xlen() const {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1432 :         _Xlength_error("deque<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEBAXXZ ENDP ; std::deque<Point,std::allocator<Point> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
;	COMDAT ??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ PROC ; std::deque<Point,std::allocator<Point> >::~deque<Point,std::allocator<Point> >, COMDAT

; 867  :     ~deque() noexcept {

$LN93:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 1009 :         return _Mysize() == 0;

  00012	33 f6		 xor	 esi, esi
  00014	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00018	48 85 c9	 test	 rcx, rcx

; 1482 :         while (!empty()) {

  0001b	74 17		 je	 SHORT $LN88@deque
  0001d	0f 1f 00	 npad	 3
$LL4@deque:

; 1153 :         if (--_Mysize() == 0) {

  00020	48 8d 41 ff	 lea	 rax, QWORD PTR [rcx-1]
  00024	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 85 c0	 test	 rax, rax
  0002e	75 f0		 jne	 SHORT $LL4@deque

; 1154 :             _Myoff() = 0;

  00030	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi
$LN88@deque:

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00034	48 8b 5f 10	 mov	 rbx, QWORD PTR [rdi+16]
  00038	48 85 db	 test	 rbx, rbx
  0003b	74 22		 je	 SHORT $LN7@deque
  0003d	0f 1f 00	 npad	 3
$LL6@deque:

; 1487 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  00040	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00044	48 ff cb	 dec	 rbx
  00047	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]
  0004b	48 85 c9	 test	 rcx, rcx
  0004e	74 0a		 je	 SHORT $LN25@deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00050	ba 10 00 00 00	 mov	 edx, 16
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN25@deque:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  0005a	48 85 db	 test	 rbx, rbx
  0005d	75 e1		 jne	 SHORT $LL6@deque
$LN7@deque:

; 1488 :                 _Getal().deallocate(_Map()[_Block], _Block_size);
; 1489 :                 _Destroy_in_place(_Map()[_Block]);
; 1490 :             }
; 1491 :         }
; 1492 : 
; 1493 :         if (_Map() != _Mapptr()) {

  0005f	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00063	48 85 c9	 test	 rcx, rcx
  00066	74 2e		 je	 SHORT $LN43@deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00068	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0006c	48 c1 e2 03	 shl	 rdx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00070	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00077	72 18		 jb	 SHORT $LN53@deque

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00079	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0007d	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00081	49 2b c8	 sub	 rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00084	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00088	48 83 f8 1f	 cmp	 rax, 31
  0008c	77 2f		 ja	 SHORT $LN50@deque

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0008e	49 8b c8	 mov	 rcx, r8
$LN53@deque:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00091	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN43@deque:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00096	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00099	ba 10 00 00 00	 mov	 edx, 16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0009e	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1497 :         _Mapsize() = 0;

  000a1	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 1498 :         _Map()     = _Mapptr();

  000a5	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 871  :     }

  000a9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ae	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5f		 pop	 rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000b8	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN50@deque:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000c3	cc		 int	 3
$LN90@deque:
??1?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@QEAA@XZ ENDP ; std::deque<Point,std::allocator<Point> >::~deque<Point,std::allocator<Point> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4Cmathlibrary@@QEAAAEAV0@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??4Cmathlibrary@@QEAAAEAV0@$$QEAV0@@Z PROC		; Cmathlibrary::operator=, COMDAT
  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??4Cmathlibrary@@QEAAAEAV0@$$QEAV0@@Z ENDP		; Cmathlibrary::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4Cmathlibrary@@QEAAAEAV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??4Cmathlibrary@@QEAAAEAV0@AEBV0@@Z PROC		; Cmathlibrary::operator=, COMDAT
  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??4Cmathlibrary@@QEAAAEAV0@AEBV0@@Z ENDP		; Cmathlibrary::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
;	COMDAT ?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z
_TEXT	SEGMENT
S$ = 32
this$ = 144
tv2488 = 152
points$ = 152
n$ = 160
?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z PROC	; Cmathlibrary::convexHull, COMDAT

; 74   : {

$LN412:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00017	49 63 f0	 movsxd	 rsi, r8d
  0001a	48 8b da	 mov	 rbx, rdx

; 75   :   // Find the bottommost point
; 76   :   int ymin = points[0].y, min = 0;

  0001d	44 8b 52 04	 mov	 r10d, DWORD PTR [rdx+4]
  00021	45 33 db	 xor	 r11d, r11d
  00024	ba 01 00 00 00	 mov	 edx, 1

; 77   :   for (int i = 1; i < n; i++)

  00029	3b f2		 cmp	 esi, edx
  0002b	7e 30		 jle	 SHORT $LN3@convexHull
  0002d	45 33 c9	 xor	 r9d, r9d
  00030	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
$LL4@convexHull:

; 78   :   {
; 79   :     int y = points[i].y;

  00034	44 8b 41 04	 mov	 r8d, DWORD PTR [rcx+4]

; 80   : 
; 81   :     // Pick the bottom-most or chose the left
; 82   :     // most point in case of tie
; 83   :     if ((y < ymin) || (ymin == y &&

  00038	45 3b c2	 cmp	 r8d, r10d
  0003b	7c 0a		 jl	 SHORT $LN18@convexHull
  0003d	75 14		 jne	 SHORT $LN2@convexHull
  0003f	41 8b 04 19	 mov	 eax, DWORD PTR [r9+rbx]
  00043	39 01		 cmp	 DWORD PTR [rcx], eax
  00045	7d 0c		 jge	 SHORT $LN2@convexHull
$LN18@convexHull:

; 84   :       points[i].x < points[min].x))
; 85   :       ymin = points[i].y, min = i;

  00047	45 8b d0	 mov	 r10d, r8d
  0004a	44 8b da	 mov	 r11d, edx
  0004d	4c 8b c9	 mov	 r9, rcx
  00050	4c 2b cb	 sub	 r9, rbx
$LN2@convexHull:

; 77   :   for (int i = 1; i < n; i++)

  00053	ff c2		 inc	 edx
  00055	48 83 c1 08	 add	 rcx, 8
  00059	3b d6		 cmp	 edx, esi
  0005b	7c d7		 jl	 SHORT $LL4@convexHull
$LN3@convexHull:

; 86   :   }
; 87   : 
; 88   :   // Place the bottom-most point at first position
; 89   :   swap(points[0], points[min]);

  0005d	49 63 c3	 movsxd	 rax, r11d
  00060	48 8d 14 c3	 lea	 rdx, QWORD PTR [rbx+rax*8]

; 30   :   Point temp = p1;

  00064	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 31   :   p1 = p2;

  00067	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0006a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 32   :   p2 = temp;

  0006d	48 89 02	 mov	 QWORD PTR [rdx], rax

; 90   : 
; 91   :   // Sort n-1 points with respect to the first point.
; 92   :   // A point p1 comes before p2 in sorted output if p2
; 93   :   // has larger polar angle (in counterclockwise
; 94   :   // direction) than p1
; 95   :   p0 = points[0];

  00070	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00073	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?p0@@3UPoint@@A, rax ; p0

; 96   :   qsort(&points[1], n - 1, sizeof(Point), compare);

  0007a	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  0007d	48 63 f8	 movsxd	 rdi, eax
  00080	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?compare@@YAHPEBX0@Z ; compare
  00087	41 b8 08 00 00
	00		 mov	 r8d, 8
  0008d	48 8b d7	 mov	 rdx, rdi
  00090	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort

; 97   : 
; 98   :   // If two or more points make same angle with p0,
; 99   :   // Remove all but the one that is farthest from p0
; 100  :   // Remember that, in above sorting, our criteria was
; 101  :   // to keep the farthest point at the end when more than
; 102  :   // one points have same angle.
; 103  :   int m = 1; // Initialize size of modified array

  0009a	41 bc 01 00 00
	00		 mov	 r12d, 1

; 104  :   for (int i = 1; i < n; i++)

  000a0	4c 8b ee	 mov	 r13, rsi
  000a3	49 3b f4	 cmp	 rsi, r12
  000a6	0f 8e 70 04 00
	00		 jle	 $LN350@convexHull
  000ac	41 8b cc	 mov	 ecx, r12d
  000af	4c 8d 7b 08	 lea	 r15, QWORD PTR [rbx+8]
$LL7@convexHull:

; 105  :   {
; 106  :     // Keep removing i while angle of i and i+1 is same
; 107  :     // with respect to p0
; 108  :     while (i < n - 1 && orientation(p0, points[i],

  000b3	48 3b cf	 cmp	 rcx, rdi
  000b6	7d 52		 jge	 SHORT $LN9@convexHull
  000b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?p0@@3UPoint@@A ; p0
  000bf	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?p0@@3UPoint@@A+4
  000c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL8@convexHull:
  000d0	4c 8b 54 cb 08	 mov	 r10, QWORD PTR [rbx+rcx*8+8]
  000d5	4c 8b 0c cb	 mov	 r9, QWORD PTR [rbx+rcx*8]
  000d9	4d 8b d9	 mov	 r11, r9
  000dc	49 c1 eb 20	 shr	 r11, 32			; 00000020H
  000e0	4d 8b c2	 mov	 r8, r10
  000e3	49 c1 e8 20	 shr	 r8, 32			; 00000020H
  000e7	45 2b c3	 sub	 r8d, r11d

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  000ea	41 8b d1	 mov	 edx, r9d
  000ed	2b d0		 sub	 edx, eax
  000ef	44 0f af c2	 imul	 r8d, edx
  000f3	44 2b de	 sub	 r11d, esi
  000f6	45 2b d1	 sub	 r10d, r9d
  000f9	45 0f af da	 imul	 r11d, r10d
  000fd	45 3b d8	 cmp	 r11d, r8d

; 51   :     (q.x - p.x) * (r.y - q.y);
; 52   : 
; 53   :   if (val == 0) return 0;  // colinear

  00100	75 08		 jne	 SHORT $LN9@convexHull

; 109  :       points[i + 1]) == 0)
; 110  :       i++;

  00102	48 ff c1	 inc	 rcx

; 105  :   {
; 106  :     // Keep removing i while angle of i and i+1 is same
; 107  :     // with respect to p0
; 108  :     while (i < n - 1 && orientation(p0, points[i],

  00105	48 3b cf	 cmp	 rcx, rdi
  00108	7c c6		 jl	 SHORT $LL8@convexHull
$LN9@convexHull:

; 111  : 
; 112  : 
; 113  :     points[m] = points[i];

  0010a	48 8b 04 cb	 mov	 rax, QWORD PTR [rbx+rcx*8]
  0010e	49 89 07	 mov	 QWORD PTR [r15], rax

; 114  :     m++;  // Update size of modified array

  00111	41 ff c4	 inc	 r12d
  00114	49 83 c7 08	 add	 r15, 8

; 104  :   for (int i = 1; i < n; i++)

  00118	48 ff c1	 inc	 rcx
  0011b	49 3b cd	 cmp	 rcx, r13
  0011e	7c 93		 jl	 SHORT $LL7@convexHull

; 115  :   }
; 116  : 
; 117  :   // If modified array of points has less than 3 points,
; 118  :   // convex hull is not possible
; 119  :   if (m < 3) return;

  00120	41 83 fc 03	 cmp	 r12d, 3
  00124	0f 8c f2 03 00
	00		 jl	 $LN350@convexHull
  0012a	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1089 :     _Container_proxy* _Myproxy = nullptr;

  0012d	f3 0f 7f 45 d0	 movdqu	 XMMWORD PTR S$[rbp-80], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 561  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  00132	33 f6		 xor	 esi, esi
  00134	48 89 75 e0	 mov	 QWORD PTR S$[rbp-64], rsi
  00138	48 89 75 e8	 mov	 QWORD PTR S$[rbp-56], rsi
  0013c	48 89 75 f0	 mov	 QWORD PTR S$[rbp-48], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00140	8d 4e 10	 lea	 ecx, QWORD PTR [rsi+16]
  00143	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 1059 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00148	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi

; 1076 :         _Myproxy            = _New_proxy;

  0014c	48 89 45 d0	 mov	 QWORD PTR S$[rbp-80], rax

; 1077 :         _New_proxy->_Mycont = this;

  00150	48 8d 4d d0	 lea	 rcx, QWORD PTR S$[rbp-80]
  00154	48 89 08	 mov	 QWORD PTR [rax], rcx
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 124  :   S.push(points[0]);

  00157	48 8b d3	 mov	 rdx, rbx
  0015a	48 8d 4d d0	 lea	 rcx, QWORD PTR S$[rbp-80]
  0015e	e8 00 00 00 00	 call	 ?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::push

; 125  :   S.push(points[1]);

  00163	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  00167	48 8d 4d d0	 lea	 rcx, QWORD PTR S$[rbp-80]
  0016b	e8 00 00 00 00	 call	 ?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::push

; 126  :   S.push(points[2]);

  00170	48 8d 53 10	 lea	 rdx, QWORD PTR [rbx+16]
  00174	48 8d 4d d0	 lea	 rcx, QWORD PTR S$[rbp-80]
  00178	e8 00 00 00 00	 call	 ?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::push

; 129  :   for (int i = 3; i < m; i++)

  0017d	49 63 c4	 movsxd	 rax, r12d
  00180	4c 8b 4d f0	 mov	 r9, QWORD PTR S$[rbp-48]
  00184	48 83 f8 03	 cmp	 rax, 3
  00188	0f 8e 31 02 00
	00		 jle	 $LN371@convexHull
  0018e	4c 8d 63 18	 lea	 r12, QWORD PTR [rbx+24]
  00192	48 83 c0 fd	 add	 rax, -3
  00196	48 89 45 48	 mov	 QWORD PTR tv2488[rbp-80], rax
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL12@convexHull:

; 134  :     while (S.size() > 1 && orientation(nextToTop(S), S.top(), points[i]) != 2)

  001a0	49 83 f9 01	 cmp	 r9, 1
  001a4	0f 86 6e 01 00
	00		 jbe	 $LN402@convexHull
  001aa	48 8b 55 e8	 mov	 rdx, QWORD PTR S$[rbp-56]
  001ae	66 90		 npad	 2
$LL13@convexHull:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 68   :         --_Myoff;

  001b0	49 8d 49 ff	 lea	 rcx, QWORD PTR [r9-1]
  001b4	48 03 ca	 add	 rcx, rdx

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  001b7	48 8b 5d e0	 mov	 rbx, QWORD PTR S$[rbp-64]
  001bb	48 ff cb	 dec	 rbx
  001be	48 8b c1	 mov	 rax, rcx
  001c1	48 d1 e8	 shr	 rax, 1
  001c4	48 23 d8	 and	 rbx, rax

; 48   :         _Size_type _Off   = _Myoff % _Block_size;

  001c7	83 e1 01	 and	 ecx, 1

; 49   :         return _Mycont->_Map[_Block][_Off];

  001ca	48 8b 45 d8	 mov	 rax, QWORD PTR S$[rbp-72]
  001ce	48 8b 1c d8	 mov	 rbx, QWORD PTR [rax+rbx*8]
  001d2	4c 8d 2c cb	 lea	 r13, QWORD PTR [rbx+rcx*8]
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 17   :   Point p = S.top();

  001d6	48 8b 1c cb	 mov	 rbx, QWORD PTR [rbx+rcx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1153 :         if (--_Mysize() == 0) {

  001da	49 83 e9 01	 sub	 r9, 1
  001de	4c 89 4d f0	 mov	 QWORD PTR S$[rbp-48], r9
  001e2	48 0f 44 d6	 cmove	 rdx, rsi
  001e6	48 89 55 e8	 mov	 QWORD PTR S$[rbp-56], rdx
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 20   :   *((unsigned int*)0) = 0xDEAD; //TEST crash: write access violation

  001ea	b8 ad de 00 00	 mov	 eax, 57005		; 0000deadH
  001ef	a3 00 00 00 00
	00 00 00 00	 mov	 DWORD PTR ds:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 920  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  001f8	4c 8b 4d e8	 mov	 r9, QWORD PTR S$[rbp-56]
  001fc	48 8b 75 f0	 mov	 rsi, QWORD PTR S$[rbp-48]
  00200	4d 8d 04 31	 lea	 r8, QWORD PTR [r9+rsi]

; 68   :         --_Myoff;

  00204	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  00208	4c 8b 55 e0	 mov	 r10, QWORD PTR S$[rbp-64]
  0020c	49 8d 4a ff	 lea	 rcx, QWORD PTR [r10-1]
  00210	48 8b c2	 mov	 rax, rdx
  00213	48 d1 e8	 shr	 rax, 1
  00216	48 23 c8	 and	 rcx, rax

; 48   :         _Size_type _Off   = _Myoff % _Block_size;

  00219	83 e2 01	 and	 edx, 1

; 49   :         return _Mycont->_Map[_Block][_Off];

  0021c	4c 8b 5d d8	 mov	 r11, QWORD PTR S$[rbp-72]
  00220	49 8b 04 cb	 mov	 rax, QWORD PTR [r11+rcx*8]
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 22   :   Point res = S.top();

  00224	48 8b 3c d0	 mov	 rdi, QWORD PTR [rax+rdx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  00228	44 8b ff	 mov	 r15d, edi
  0022b	41 f6 c0 01	 test	 r8b, 1
  0022f	75 2a		 jne	 SHORT $LN156@convexHull
  00231	48 8d 46 02	 lea	 rax, QWORD PTR [rsi+2]
  00235	48 d1 e8	 shr	 rax, 1
  00238	4c 3b d0	 cmp	 r10, rax
  0023b	77 1e		 ja	 SHORT $LN156@convexHull

; 1114 :             _Growmap(1);

  0023d	ba 01 00 00 00	 mov	 edx, 1
  00242	48 8d 4d d0	 lea	 rcx, QWORD PTR S$[rbp-80]
  00246	e8 00 00 00 00	 call	 ?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z ; std::deque<Point,std::allocator<Point> >::_Growmap
  0024b	48 8b 75 f0	 mov	 rsi, QWORD PTR S$[rbp-48]
  0024f	4c 8b 4d e8	 mov	 r9, QWORD PTR S$[rbp-56]
  00253	4c 8b 55 e0	 mov	 r10, QWORD PTR S$[rbp-64]
  00257	4c 8b 5d d8	 mov	 r11, QWORD PTR S$[rbp-72]
$LN156@convexHull:

; 1115 :         }
; 1116 :         _Myoff() &= _Mapsize() * _Block_size - 1;

  0025b	4a 8d 04 55 ff
	ff ff ff	 lea	 rax, QWORD PTR [r10*2-1]
  00263	4c 23 c8	 and	 r9, rax
  00266	4c 89 4d e8	 mov	 QWORD PTR S$[rbp-56], r9

; 1117 :         size_type _Newoff = _Myoff() + _Mysize();

  0026a	4d 8d 34 31	 lea	 r14, QWORD PTR [r9+rsi]

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  0026e	49 8d 4a ff	 lea	 rcx, QWORD PTR [r10-1]
  00272	49 8b c6	 mov	 rax, r14
  00275	48 d1 e8	 shr	 rax, 1
  00278	48 23 c8	 and	 rcx, rax

; 1119 :         if (_Map()[_Block] == nullptr) {

  0027b	48 8d 34 cd 00
	00 00 00	 lea	 rsi, QWORD PTR [rcx*8]
  00283	49 83 3c 33 00	 cmp	 QWORD PTR [r11+rsi], 0
  00288	75 16		 jne	 SHORT $LN157@convexHull
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 85   :         return ::operator new(_Bytes);

  0028a	b9 10 00 00 00	 mov	 ecx, 16
  0028f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1120 :             _Map()[_Block] = _Getal().allocate(_Block_size);

  00294	48 8b 4d d8	 mov	 rcx, QWORD PTR S$[rbp-72]
  00298	48 89 04 31	 mov	 QWORD PTR [rcx+rsi], rax
  0029c	4c 8b 5d d8	 mov	 r11, QWORD PTR S$[rbp-72]
$LN157@convexHull:

; 1121 :         }
; 1122 : 
; 1123 :         _Alty_traits::construct(

  002a0	41 83 e6 01	 and	 r14d, 1
  002a4	49 8b 04 33	 mov	 rax, QWORD PTR [r11+rsi]
  002a8	4a 89 1c f0	 mov	 QWORD PTR [rax+r14*8], rbx

; 1124 :             _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), _STD forward<_Tys>(_Vals)...);
; 1125 : 
; 1126 :         ++_Mysize();

  002ac	4c 8b 4d f0	 mov	 r9, QWORD PTR S$[rbp-48]
  002b0	49 ff c1	 inc	 r9
  002b3	4c 89 4d f0	 mov	 QWORD PTR S$[rbp-48], r9
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 134  :     while (S.size() > 1 && orientation(nextToTop(S), S.top(), points[i]) != 2)

  002b7	4d 8b 04 24	 mov	 r8, QWORD PTR [r12]
  002bb	49 8b 55 00	 mov	 rdx, QWORD PTR [r13]
  002bf	48 8b ca	 mov	 rcx, rdx
  002c2	48 c1 e9 20	 shr	 rcx, 32			; 00000020H

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  002c6	48 c1 ef 20	 shr	 rdi, 32			; 00000020H
  002ca	44 8b d1	 mov	 r10d, ecx
  002cd	44 2b d7	 sub	 r10d, edi
  002d0	41 8b c0	 mov	 eax, r8d
  002d3	2b c2		 sub	 eax, edx
  002d5	44 0f af d0	 imul	 r10d, eax

; 134  :     while (S.size() > 1 && orientation(nextToTop(S), S.top(), points[i]) != 2)

  002d9	49 c1 e8 20	 shr	 r8, 32			; 00000020H

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  002dd	44 2b c1	 sub	 r8d, ecx

; 134  :     while (S.size() > 1 && orientation(nextToTop(S), S.top(), points[i]) != 2)

  002e0	41 2b d7	 sub	 edx, r15d

; 50   :   int val = (q.y - p.y) * (r.x - q.x) -

  002e3	44 0f af c2	 imul	 r8d, edx
  002e7	45 2b d0	 sub	 r10d, r8d

; 51   :     (q.x - p.x) * (r.y - q.y);
; 52   : 
; 53   :   if (val == 0) return 0;  // colinear

  002ea	74 05		 je	 SHORT $LN400@convexHull

; 134  :     while (S.size() > 1 && orientation(nextToTop(S), S.top(), points[i]) != 2)

  002ec	45 85 d2	 test	 r10d, r10d
  002ef	7e 25		 jle	 SHORT $LN408@convexHull
$LN400@convexHull:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1153 :         if (--_Mysize() == 0) {

  002f1	49 83 e9 01	 sub	 r9, 1
  002f5	4c 89 4d f0	 mov	 QWORD PTR S$[rbp-48], r9
  002f9	48 8b 55 e8	 mov	 rdx, QWORD PTR S$[rbp-56]
  002fd	be 00 00 00 00	 mov	 esi, 0
  00302	48 0f 44 d6	 cmove	 rdx, rsi
  00306	48 89 55 e8	 mov	 QWORD PTR S$[rbp-56], rdx
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 134  :     while (S.size() > 1 && orientation(nextToTop(S), S.top(), points[i]) != 2)

  0030a	49 83 f9 01	 cmp	 r9, 1
  0030e	0f 87 9c fe ff
	ff		 ja	 $LL13@convexHull
  00314	eb 06		 jmp	 SHORT $LN14@convexHull
$LN408@convexHull:
  00316	33 f6		 xor	 esi, esi
$LN402@convexHull:
  00318	48 8b 55 e8	 mov	 rdx, QWORD PTR S$[rbp-56]
$LN14@convexHull:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  0031c	41 8d 04 11	 lea	 eax, DWORD PTR [r9+rdx]
  00320	48 8b 4d e0	 mov	 rcx, QWORD PTR S$[rbp-64]
  00324	a8 01		 test	 al, 1
  00326	75 26		 jne	 SHORT $LN210@convexHull
  00328	49 8d 41 02	 lea	 rax, QWORD PTR [r9+2]
  0032c	48 d1 e8	 shr	 rax, 1
  0032f	48 3b c8	 cmp	 rcx, rax
  00332	77 1a		 ja	 SHORT $LN210@convexHull

; 1114 :             _Growmap(1);

  00334	ba 01 00 00 00	 mov	 edx, 1
  00339	48 8d 4d d0	 lea	 rcx, QWORD PTR S$[rbp-80]
  0033d	e8 00 00 00 00	 call	 ?_Growmap@?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@AEAAX_K@Z ; std::deque<Point,std::allocator<Point> >::_Growmap

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  00342	4c 8b 4d f0	 mov	 r9, QWORD PTR S$[rbp-48]
  00346	48 8b 55 e8	 mov	 rdx, QWORD PTR S$[rbp-56]
  0034a	48 8b 4d e0	 mov	 rcx, QWORD PTR S$[rbp-64]
$LN210@convexHull:

; 1115 :         }
; 1116 :         _Myoff() &= _Mapsize() * _Block_size - 1;

  0034e	48 8d 04 4d ff
	ff ff ff	 lea	 rax, QWORD PTR [rcx*2-1]
  00356	48 23 d0	 and	 rdx, rax
  00359	48 89 55 e8	 mov	 QWORD PTR S$[rbp-56], rdx

; 1117 :         size_type _Newoff = _Myoff() + _Mysize();

  0035d	4a 8d 1c 0a	 lea	 rbx, QWORD PTR [rdx+r9]

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  00361	48 ff c9	 dec	 rcx
  00364	48 8b c3	 mov	 rax, rbx
  00367	48 d1 e8	 shr	 rax, 1
  0036a	48 23 c8	 and	 rcx, rax

; 1119 :         if (_Map()[_Block] == nullptr) {

  0036d	48 8d 3c cd 00
	00 00 00	 lea	 rdi, QWORD PTR [rcx*8]
  00375	48 8b 4d d8	 mov	 rcx, QWORD PTR S$[rbp-72]
  00379	48 83 3c 39 00	 cmp	 QWORD PTR [rcx+rdi], 0
  0037e	75 16		 jne	 SHORT $LN211@convexHull
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00380	b9 10 00 00 00	 mov	 ecx, 16
  00385	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1120 :             _Map()[_Block] = _Getal().allocate(_Block_size);

  0038a	48 8b 4d d8	 mov	 rcx, QWORD PTR S$[rbp-72]
  0038e	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  00392	48 8b 4d d8	 mov	 rcx, QWORD PTR S$[rbp-72]
$LN211@convexHull:

; 1121 :         }
; 1122 : 
; 1123 :         _Alty_traits::construct(

  00396	83 e3 01	 and	 ebx, 1
  00399	48 8b 0c 39	 mov	 rcx, QWORD PTR [rcx+rdi]
  0039d	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  003a1	48 89 04 d9	 mov	 QWORD PTR [rcx+rbx*8], rax

; 1124 :             _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), _STD forward<_Tys>(_Vals)...);
; 1125 : 
; 1126 :         ++_Mysize();

  003a5	4c 8b 4d f0	 mov	 r9, QWORD PTR S$[rbp-48]
  003a9	49 ff c1	 inc	 r9
  003ac	4c 89 4d f0	 mov	 QWORD PTR S$[rbp-48], r9
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 129  :   for (int i = 3; i < m; i++)

  003b0	49 83 c4 08	 add	 r12, 8
  003b4	48 83 6d 48 01	 sub	 QWORD PTR tv2488[rbp-80], 1
  003b9	0f 85 e1 fd ff
	ff		 jne	 $LL12@convexHull
$LN371@convexHull:

; 140  :   while (!S.empty())

  003bf	4d 85 c9	 test	 r9, r9
  003c2	0f 84 aa 00 00
	00		 je	 $LN405@convexHull
  003c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL15@convexHull:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 920  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  003d0	48 8b 5d e8	 mov	 rbx, QWORD PTR S$[rbp-56]

; 68   :         --_Myoff;

  003d4	48 ff cb	 dec	 rbx
  003d7	49 03 d9	 add	 rbx, r9

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  003da	48 8b 4d e0	 mov	 rcx, QWORD PTR S$[rbp-64]
  003de	48 ff c9	 dec	 rcx
  003e1	48 8b c3	 mov	 rax, rbx
  003e4	48 d1 e8	 shr	 rax, 1
  003e7	48 23 c8	 and	 rcx, rax

; 48   :         _Size_type _Off   = _Myoff % _Block_size;

  003ea	83 e3 01	 and	 ebx, 1

; 49   :         return _Mycont->_Map[_Block][_Off];

  003ed	48 8b 45 d8	 mov	 rax, QWORD PTR S$[rbp-72]
  003f1	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 142  :     Point p = S.top();

  003f5	48 8b 1c d9	 mov	 rbx, QWORD PTR [rcx+rbx*8]

; 143  :     std::cout << "(" << p.x << ", " << p.y << ")" << std::endl;

  003f9	48 8b fb	 mov	 rdi, rbx
  003fc	48 c1 ef 20	 shr	 rdi, 32			; 00000020H
  00400	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01ODHLEDKK@?$CI@
  00407	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0040e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00413	48 8b c8	 mov	 rcx, rax
  00416	8b d3		 mov	 edx, ebx
  00418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0041e	48 8b c8	 mov	 rcx, rax
  00421	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5@
  00428	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0042d	48 8b c8	 mov	 rcx, rax
  00430	8b d7		 mov	 edx, edi
  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00438	48 8b c8	 mov	 rcx, rax
  0043b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
  00442	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00447	48 8b c8	 mov	 rcx, rax
  0044a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00451	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1153 :         if (--_Mysize() == 0) {

  00457	4c 8b 4d f0	 mov	 r9, QWORD PTR S$[rbp-48]
  0045b	49 83 e9 01	 sub	 r9, 1
  0045f	4c 89 4d f0	 mov	 QWORD PTR S$[rbp-48], r9
  00463	0f 85 67 ff ff
	ff		 jne	 $LL15@convexHull

; 1154 :             _Myoff() = 0;

  00469	48 8b c6	 mov	 rax, rsi
  0046c	48 89 45 e8	 mov	 QWORD PTR S$[rbp-56], rax
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 140  :   while (!S.empty())

  00470	eb 04		 jmp	 SHORT $LN401@convexHull
$LN405@convexHull:
  00472	48 8b 45 e8	 mov	 rax, QWORD PTR S$[rbp-56]
$LN401@convexHull:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1009 :         return _Mysize() == 0;

  00476	4d 85 c9	 test	 r9, r9

; 1482 :         while (!empty()) {

  00479	74 1a		 je	 SHORT $LN288@convexHull
  0047b	0f 1f 44 00 00	 npad	 5
$LL287@convexHull:

; 1153 :         if (--_Mysize() == 0) {

  00480	49 83 e9 01	 sub	 r9, 1
  00484	48 0f 44 c6	 cmove	 rax, rsi

; 1009 :         return _Mysize() == 0;

  00488	4d 85 c9	 test	 r9, r9

; 1482 :         while (!empty()) {

  0048b	75 f3		 jne	 SHORT $LL287@convexHull

; 1153 :         if (--_Mysize() == 0) {

  0048d	4c 89 4d f0	 mov	 QWORD PTR S$[rbp-48], r9
  00491	48 89 45 e8	 mov	 QWORD PTR S$[rbp-56], rax
$LN288@convexHull:

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00495	48 8b 5d e0	 mov	 rbx, QWORD PTR S$[rbp-64]
  00499	48 8b 4d d8	 mov	 rcx, QWORD PTR S$[rbp-72]
  0049d	48 85 db	 test	 rbx, rbx
  004a0	74 26		 je	 SHORT $LN290@convexHull
$LL289@convexHull:

; 1487 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  004a2	48 ff cb	 dec	 rbx
  004a5	48 8b 04 d9	 mov	 rax, QWORD PTR [rcx+rbx*8]
  004a9	48 85 c0	 test	 rax, rax
  004ac	74 11		 je	 SHORT $LN308@convexHull
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  004ae	ba 10 00 00 00	 mov	 edx, 16
  004b3	48 8b c8	 mov	 rcx, rax
  004b6	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  004bb	48 8b 4d d8	 mov	 rcx, QWORD PTR S$[rbp-72]
$LN308@convexHull:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  004bf	48 85 db	 test	 rbx, rbx
  004c2	75 de		 jne	 SHORT $LL289@convexHull
  004c4	48 8b 5d e0	 mov	 rbx, QWORD PTR S$[rbp-64]
$LN290@convexHull:

; 1488 :                 _Getal().deallocate(_Map()[_Block], _Block_size);
; 1489 :                 _Destroy_in_place(_Map()[_Block]);
; 1490 :             }
; 1491 :         }
; 1492 : 
; 1493 :         if (_Map() != _Mapptr()) {

  004c8	48 85 c9	 test	 rcx, rcx
  004cb	74 35		 je	 SHORT $LN326@convexHull
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004cd	48 8d 14 dd 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*8]
  004d5	48 8b c1	 mov	 rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004d8	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  004df	72 1c		 jb	 SHORT $LN336@convexHull

; 155  :     _Bytes += _Non_user_size;

  004e1	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004e5	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  004e9	48 2b c1	 sub	 rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004ec	48 83 c0 f8	 add	 rax, -8
  004f0	48 83 f8 1f	 cmp	 rax, 31
  004f4	76 07		 jbe	 SHORT $LN336@convexHull
  004f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  004fc	cc		 int	 3
$LN336@convexHull:

; 264  :         ::operator delete(_Ptr, _Bytes);

  004fd	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN326@convexHull:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1497 :         _Mapsize() = 0;

  00502	48 89 75 e0	 mov	 QWORD PTR S$[rbp-64], rsi

; 1498 :         _Map()     = _Mapptr();

  00506	48 89 75 d8	 mov	 QWORD PTR S$[rbp-72], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0050a	48 8b 4d d0	 mov	 rcx, QWORD PTR S$[rbp-80]

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0050e	48 89 75 d0	 mov	 QWORD PTR S$[rbp-80], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00512	ba 10 00 00 00	 mov	 edx, 16
  00517	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN350@convexHull:
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 146  : }

  0051c	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00524	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00528	41 5f		 pop	 r15
  0052a	41 5e		 pop	 r14
  0052c	41 5d		 pop	 r13
  0052e	41 5c		 pop	 r12
  00530	5f		 pop	 rdi
  00531	5e		 pop	 rsi
  00532	5d		 pop	 rbp
  00533	c3		 ret	 0
$LN409@convexHull:
?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z ENDP	; Cmathlibrary::convexHull
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
S$ = 32
this$ = 144
tv2488 = 152
points$ = 152
n$ = 160
?dtor$0@?0??convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z@4HA PROC ; `Cmathlibrary::convexHull'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR S$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0??convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z@4HA ENDP ; `Cmathlibrary::convexHull'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
S$ = 32
this$ = 144
tv2488 = 152
points$ = 152
n$ = 160
?dtor$0@?0??convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z@4HA PROC ; `Cmathlibrary::convexHull'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR S$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0??convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z@4HA ENDP ; `Cmathlibrary::convexHull'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
;	COMDAT ?swap@Cmathlibrary@@AEAAXAEAUPoint@@0@Z
_TEXT	SEGMENT
this$ = 8
p1$ = 16
p2$ = 24
?swap@Cmathlibrary@@AEAAXAEAUPoint@@0@Z PROC		; Cmathlibrary::swap, COMDAT

; 30   :   Point temp = p1;
; 31   :   p1 = p2;

  00000	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00003	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00006	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 32   :   p2 = temp;

  00009	49 89 00	 mov	 QWORD PTR [r8], rax

; 33   : }

  0000c	c3		 ret	 0
?swap@Cmathlibrary@@AEAAXAEAUPoint@@0@Z ENDP		; Cmathlibrary::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
;	COMDAT ?nextToTop@Cmathlibrary@@AEAA?AUPoint@@AEAV?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
this$ = 64
p$ = 72
__$ReturnUdt$ = 72
S$ = 80
?nextToTop@Cmathlibrary@@AEAA?AUPoint@@AEAV?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@@Z PROC ; Cmathlibrary::nextToTop, COMDAT

; 16   : {

$LN59:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 920  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  0000a	4d 8b 58 20	 mov	 r11, QWORD PTR [r8+32]

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  0000e	49 8b c8	 mov	 rcx, r8

; 920  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00011	4d 8b 50 18	 mov	 r10, QWORD PTR [r8+24]
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 16   : {

  00015	49 8b d8	 mov	 rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 920  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00018	49 ff ca	 dec	 r10

; 44   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  0001b	48 89 5c 24 20	 mov	 QWORD PTR $T2[rsp], rbx

; 68   :         --_Myoff;

  00020	4d 03 d3	 add	 r10, r11
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 16   : {

  00023	48 8b fa	 mov	 rdi, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  00026	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0002a	4d 8b ca	 mov	 r9, r10
  0002d	48 ff c8	 dec	 rax
  00030	49 d1 e9	 shr	 r9, 1
  00033	4c 23 c8	 and	 r9, rax

; 49   :         return _Mycont->_Map[_Block][_Off];

  00036	41 83 e2 01	 and	 r10d, 1
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 17   :   Point p = S.top();

  0003a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0003e	4a 8b 04 c8	 mov	 rax, QWORD PTR [rax+r9*8]
  00042	4a 8b 0c d0	 mov	 rcx, QWORD PTR [rax+r10*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1153 :         if (--_Mysize() == 0) {

  00046	49 8d 43 ff	 lea	 rax, QWORD PTR [r11-1]
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 17   :   Point p = S.top();

  0004a	48 89 4c 24 48	 mov	 QWORD PTR p$[rsp], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1153 :         if (--_Mysize() == 0) {

  0004f	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00053	48 85 c0	 test	 rax, rax
  00056	75 04		 jne	 SHORT $LN56@nextToTop

; 1154 :             _Myoff() = 0;

  00058	49 89 40 18	 mov	 QWORD PTR [r8+24], rax
$LN56@nextToTop:
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 20   :   *((unsigned int*)0) = 0xDEAD; //TEST crash: write access violation

  0005c	c7 04 25 00 00
	00 00 ad de 00
	00		 mov	 DWORD PTR ds:0, 57005	; 0000deadH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  00067	48 8b cb	 mov	 rcx, rbx

; 920  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  0006a	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]
  0006e	49 03 40 20	 add	 rax, QWORD PTR [r8+32]

; 68   :         --_Myoff;

  00072	4c 8d 40 ff	 lea	 r8, QWORD PTR [rax-1]

; 44   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00076	48 89 5c 24 20	 mov	 QWORD PTR $T1[rsp], rbx

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  0007b	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0007f	49 8b d0	 mov	 rdx, r8
  00082	48 ff c8	 dec	 rax
  00085	48 d1 ea	 shr	 rdx, 1
  00088	48 23 d0	 and	 rdx, rax

; 49   :         return _Mycont->_Map[_Block][_Off];

  0008b	41 83 e0 01	 and	 r8d, 1
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp

; 22   :   Point res = S.top();

  0008f	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00093	48 8b 04 d0	 mov	 rax, QWORD PTR [rax+rdx*8]

; 23   :   S.push(p);

  00097	48 8d 54 24 48	 lea	 rdx, QWORD PTR p$[rsp]
  0009c	4a 8b 0c c0	 mov	 rcx, QWORD PTR [rax+r8*8]
  000a0	48 89 0f	 mov	 QWORD PTR [rdi], rcx
  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	e8 00 00 00 00	 call	 ?push@?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@QEAAXAEBUPoint@@@Z ; std::stack<Point,std::deque<Point,std::allocator<Point> > >::push

; 24   :   return res;
; 25   : }

  000ab	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b0	48 8b c7	 mov	 rax, rdi
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
?nextToTop@Cmathlibrary@@AEAA?AUPoint@@AEAV?$stack@UPoint@@V?$deque@UPoint@@V?$allocator@UPoint@@@std@@@std@@@std@@@Z ENDP ; Cmathlibrary::nextToTop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.cpp
;	COMDAT ?calc_convex_hull@Cmathlibrary@@QEAAHXZ
_TEXT	SEGMENT
points$ = 32
__$ArrayPad$ = 96
this$ = 128
?calc_convex_hull@Cmathlibrary@@QEAAHXZ PROC		; Cmathlibrary::calc_convex_hull, COMDAT

; 150  : {

$LN4:
  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 151  :   Point points[] = { {0, 3}, {1, 1}, {2, 2}, {4, 4},

  00013	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000001000000010000000300000000

; 152  :                     {0, 0}, {1, 2}, {3, 1}, {3, 3} };
; 153  :   int n = sizeof(points) / sizeof(points[0]);
; 154  :   convexHull(points, n);

  0001b	48 8d 54 24 20	 lea	 rdx, QWORD PTR points$[rsp]
  00020	66 0f 6f 0d 00
	00 00 00	 movdqa	 xmm1, XMMWORD PTR __xmm@00000004000000040000000200000002
  00028	41 b8 08 00 00
	00		 mov	 r8d, 8
  0002e	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR points$[rsp], xmm0
  00034	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000002000000010000000000000000
  0003c	66 0f 7f 4c 24
	30		 movdqa	 XMMWORD PTR points$[rsp+16], xmm1
  00042	66 0f 6f 0d 00
	00 00 00	 movdqa	 xmm1, XMMWORD PTR __xmm@00000003000000030000000100000003
  0004a	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR points$[rsp+32], xmm0
  00050	66 0f 7f 4c 24
	50		 movdqa	 XMMWORD PTR points$[rsp+48], xmm1
  00056	e8 00 00 00 00	 call	 ?convexHull@Cmathlibrary@@AEAAXQEAUPoint@@H@Z ; Cmathlibrary::convexHull

; 155  :   return 0;

  0005b	33 c0		 xor	 eax, eax

; 156  : }

  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0006e	c3		 ret	 0
?calc_convex_hull@Cmathlibrary@@QEAAHXZ ENDP		; Cmathlibrary::calc_convex_hull
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\math_library.hpp
;	COMDAT ??0Cmathlibrary@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Cmathlibrary@@QEAA@XZ PROC				; Cmathlibrary::Cmathlibrary, COMDAT

; 25   :   {
; 26   :   }

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0Cmathlibrary@@QEAA@XZ ENDP				; Cmathlibrary::Cmathlibrary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 321  :     _THROW(bad_array_new_length{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
  0001f	cc		 int	 3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN12@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 67   :         _Data._What = _Message;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00007	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0
  0000f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 141  :     {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  0001a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 142  :     }

  0001d	48 8b c1	 mov	 rax, rcx
  00020	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN9@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN6@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN6@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	48 0f 45 c2	 cmovne	 rax, rdx

; 96   :     }

  00012	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  00029	48 8b c3	 mov	 rax, rbx
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
