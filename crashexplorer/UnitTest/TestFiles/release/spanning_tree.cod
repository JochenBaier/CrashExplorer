; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30038.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	printf
PUBLIC	?calc_mininum_spaning@@YAXXZ			; calc_mininum_spaning
PUBLIC	?minKey@@YAHQEAHQEA_N@Z				; minKey
PUBLIC	?printMST@@YAXQEAHQEAY04H@Z			; printMST
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?primMST@@YAXQEAY04H@Z				; primMST
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0M@IJPENPOG@vor?5crash?3?6@		; `string'
PUBLIC	??_C@_0O@GOKCDOKC@Edge?5?7Weight?6@		; `string'
PUBLIC	??_C@_02MCBMIIIH@?5?6@				; `string'
PUBLIC	??_C@_02OJDBNLEE@?5?7@				; `string'
PUBLIC	??_C@_03NLJIHOMM@?5?9?5@			; `string'
PUBLIC	__xmm@00000003000000000000000200000000
PUBLIC	__xmm@00000003000000000000000500000008
PUBLIC	__xmm@00000006000000000000000200000000
PUBLIC	__xmm@00000006000000070000000000000000
PUBLIC	__xmm@00000009000000000000000000000008
PUBLIC	__xmm@00000009000000070000000500000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__std_terminate:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?calc_mininum_spaning@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+154
	DD	imagerel $unwind$?calc_mininum_spaning@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?minKey@@YAHQEAHQEA_N@Z DD imagerel $LN12
	DD	imagerel $LN12+100
	DD	imagerel $unwind$?minKey@@YAHQEAHQEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?printMST@@YAXQEAHQEAY04H@Z DD imagerel $LN11
	DD	imagerel $LN11+196
	DD	imagerel $unwind$?printMST@@YAXQEAHQEAY04H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN99
	DD	imagerel $LN99+457
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?primMST@@YAXQEAY04H@Z DD imagerel $LN56
	DD	imagerel $LN56+77
	DD	imagerel $unwind$?primMST@@YAXQEAY04H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?primMST@@YAXQEAY04H@Z DD imagerel $LN56+77
	DD	imagerel $LN56+101
	DD	imagerel $chain$2$?primMST@@YAXQEAY04H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?primMST@@YAXQEAY04H@Z DD imagerel $LN56+101
	DD	imagerel $LN56+464
	DD	imagerel $chain$5$?primMST@@YAXQEAY04H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?primMST@@YAXQEAY04H@Z DD imagerel $LN56+464
	DD	imagerel $LN56+626
	DD	imagerel $chain$6$?primMST@@YAXQEAY04H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?primMST@@YAXQEAY04H@Z DD imagerel $LN56+626
	DD	imagerel $LN56+632
	DD	imagerel $chain$7$?primMST@@YAXQEAY04H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN24
	DD	imagerel $LN24+122
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+61
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT __xmm@00000009000000070000000500000000
CONST	SEGMENT
__xmm@00000009000000070000000500000000 DB 00H, 00H, 00H, 00H, 05H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 09H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000009000000000000000000000008
CONST	SEGMENT
__xmm@00000009000000000000000000000008 DB 08H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 09H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000006000000070000000000000000
CONST	SEGMENT
__xmm@00000006000000070000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 06H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000006000000000000000200000000
CONST	SEGMENT
__xmm@00000006000000000000000200000000 DB 00H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 06H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000000000000500000008
CONST	SEGMENT
__xmm@00000003000000000000000500000008 DB 08H, 00H, 00H, 00H, 05H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000000000000200000000
CONST	SEGMENT
__xmm@00000003000000000000000200000000 DB 00H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_C@_03NLJIHOMM@?5?9?5@
CONST	SEGMENT
??_C@_03NLJIHOMM@?5?9?5@ DB ' - ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OJDBNLEE@?5?7@
CONST	SEGMENT
??_C@_02OJDBNLEE@?5?7@ DB ' ', 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCBMIIIH@?5?6@
CONST	SEGMENT
??_C@_02MCBMIIIH@?5?6@ DB ' ', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GOKCDOKC@Edge?5?7Weight?6@
CONST	SEGMENT
??_C@_0O@GOKCDOKC@Edge?5?7Weight?6@ DB 'Edge ', 09H, 'Weight', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJPENPOG@vor?5crash?3?6@
CONST	SEGMENT
??_C@_0M@IJPENPOG@vor?5crash?3?6@ DB 'vor crash:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 04H
	DB	'*'
	DB	00H
	DB	'<'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0ddH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?primMST@@YAXQEAY04H@Z DD 021H
	DD	imagerel $LN56
	DD	imagerel $LN56+77
	DD	imagerel $unwind$?primMST@@YAXQEAY04H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?primMST@@YAXQEAY04H@Z DD 020021H
	DD	010e400H
	DD	imagerel $LN56+77
	DD	imagerel $LN56+101
	DD	imagerel $chain$2$?primMST@@YAXQEAY04H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?primMST@@YAXQEAY04H@Z DD 062b21H
	DD	010e42bH
	DD	011d414H
	DD	012c408H
	DD	imagerel $LN56+77
	DD	imagerel $LN56+101
	DD	imagerel $chain$2$?primMST@@YAXQEAY04H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?primMST@@YAXQEAY04H@Z DD 061821H
	DD	0197418H
	DD	0186410H
	DD	0173408H
	DD	imagerel $LN56
	DD	imagerel $LN56+77
	DD	imagerel $unwind$?primMST@@YAXQEAY04H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?primMST@@YAXQEAY04H@Z DD 041e19H
	DD	0130110H
	DD	05002f004H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0eH
	DB	0e2H
	DB	00H
	DB	'T'
	DB	02H
	DB	0b6H
	DB	06H
	DB	0d8H
	DB	04H
	DB	'L'
	DB	0aH
	DB	'&'
	DB	0cH
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	091H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __std_terminate
	DB	02eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?printMST@@YAXQEAHQEAY04H@Z DD 0a1a01H
	DD	09e41aH
	DD	08741aH
	DD	07641aH
	DD	06341aH
	DD	0f016321aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	039H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?minKey@@YAHQEAHQEA_N@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?calc_mininum_spaning@@YAXXZ DD 021919H
	DD	0150107H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00009	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0000e	84 c0		 test	 al, al
  00010	75 0a		 jne	 SHORT $LN2@sentry

; 119  :                 this->_Myostr._Osfx();

  00012	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	90		 npad	 1
$LN2@sentry:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001c	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0001f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  00026	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  0002b	48 85 c9	 test	 rcx, rcx
  0002e	74 07		 je	 SHORT $LN10@sentry

; 81   :                 _Rdbuf->_Unlock();

  00030	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00033	ff 50 10	 call	 QWORD PTR [rax+16]
  00036	90		 npad	 1
$LN10@sentry:

; 120  :             }
; 121  :         }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00004	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00007	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  0000e	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	74 07		 je	 SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	ff 50 10	 call	 QWORD PTR [rax+16]
  0001e	90		 npad	 1
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\spanning_tree.cpp
;	COMDAT ?primMST@@YAXQEAY04H@Z
_TEXT	SEGMENT
key$4$ = 32
min_index$1 = 32
key$2$ = 36
key$3$ = 40
tv1121 = 48
key$ = 56
parent$ = 80
mstSet$ = 104
__$ArrayPad$ = 112
graph$ = 176
?primMST@@YAXQEAY04H@Z PROC				; primMST, COMDAT

; 48   : {

$LN56:
  00000	40 55		 push	 rbp
  00002	41 57		 push	 r15
  00004	48 8d 6c 24 b1	 lea	 rbp, QWORD PTR [rsp-79]
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 45 27	 mov	 QWORD PTR __$ArrayPad$[rbp-73], rax
  0001e	4c 8b f9	 mov	 r15, rcx
  00021	33 c0		 xor	 eax, eax
$LL4@primMST:

; 49   : 	// Array to store constructed MST
; 50   : 	int parent[V];
; 51   : 	
; 52   : 	// Key values used to pick minimum weight edge in cut
; 53   : 	int key[V];
; 54   : 	
; 55   : 	// To represent set of vertices included in MST
; 56   : 	bool mstSet[V];
; 57   : 
; 58   : 	// Initialize all keys as INFINITE
; 59   : 	for (int i = 0; i < V; i++)
; 60   : 		key[i] = INT_MAX, mstSet[i] = false;

  00023	c7 44 85 ef ff
	ff ff 7f	 mov	 DWORD PTR key$[rbp+rax*4-73], 2147483647 ; 7fffffffH
  0002b	48 83 f8 05	 cmp	 rax, 5
  0002f	0f 83 3d 02 00
	00		 jae	 $LN13@primMST
  00035	c6 44 05 1f 00	 mov	 BYTE PTR mstSet$[rbp+rax-73], 0
  0003a	48 ff c0	 inc	 rax
  0003d	48 83 f8 05	 cmp	 rax, 5
  00041	7c e0		 jl	 SHORT $LL4@primMST

; 61   : 
; 62   : 	// Always include first 1st vertex in MST.
; 63   : 	// Make key 0 so that this vertex is picked as first vertex.
; 64   : 	key[0] = 0;
; 65   : 	parent[0] = -1; // First node is always root of MST

  00043	48 63 4d d7	 movsxd	 rcx, DWORD PTR min_index$1[rbp-73]
  00047	8b 45 fb	 mov	 eax, DWORD PTR key$[rbp-61]
  0004a	4c 8b c1	 mov	 r8, rcx
  0004d	48 89 9c 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rbx
  00055	48 89 b4 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rsi
  0005d	48 89 bc 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rdi
  00065	4c 89 a4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r12
  0006d	44 8b 65 ff	 mov	 r12d, DWORD PTR key$[rbp-57]
  00071	4c 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r13
  00079	45 33 ed	 xor	 r13d, r13d
  0007c	89 45 d7	 mov	 DWORD PTR key$4$[rbp-73], eax
  0007f	8b 45 f7	 mov	 eax, DWORD PTR key$[rbp-65]
  00082	89 45 df	 mov	 DWORD PTR key$3$[rbp-73], eax
  00085	8b 45 f3	 mov	 eax, DWORD PTR key$[rbp-69]
  00088	4c 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r14
  00090	45 8d 75 01	 lea	 r14d, QWORD PTR [r13+1]
  00094	44 89 6d ef	 mov	 DWORD PTR key$[rbp-73], r13d
  00098	c7 45 07 ff ff
	ff ff		 mov	 DWORD PTR parent$[rbp-73], -1
  0009f	48 c7 45 e7 04
	00 00 00	 mov	 QWORD PTR tv1121[rbp-73], 4
  000a7	89 45 db	 mov	 DWORD PTR key$2$[rbp-73], eax
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL7@primMST:

; 21   : 	for (int v = 0; v < V; v++)

  000b0	33 ff		 xor	 edi, edi
  000b2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000b7	33 db		 xor	 ebx, ebx
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@primMST:

; 22   : 		if (mstSet[v] == false && key[v] < min)

  000c0	80 7c 1d 1f 00	 cmp	 BYTE PTR mstSet$[rbp+rbx-73], 0
  000c5	75 23		 jne	 SHORT $LN16@primMST
  000c7	8b 74 9d ef	 mov	 esi, DWORD PTR key$[rbp+rbx*4-73]
  000cb	3b f0		 cmp	 esi, eax
  000cd	7d 1b		 jge	 SHORT $LN16@primMST

; 23   : 		{
; 24   : 			printf("vor crash:\n");

  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@IJPENPOG@vor?5crash?3?6@
  000d6	e8 00 00 00 00	 call	 printf

; 25   : 
; 26   : 			min = key[v], min_index = v;

  000db	8b c6		 mov	 eax, esi

; 27   : 			volatile int* a = reinterpret_cast<volatile int*>(NULL);
; 28   : 			*a = 1;//TEST crash: write acces violation

  000dd	44 89 34 25 00
	00 00 00	 mov	 DWORD PTR ds:0, r14d
  000e5	8b cf		 mov	 ecx, edi
  000e7	4c 8b c3	 mov	 r8, rbx
$LN16@primMST:

; 21   : 	for (int v = 0; v < V; v++)

  000ea	ff c7		 inc	 edi
  000ec	48 ff c3	 inc	 rbx
  000ef	83 ff 05	 cmp	 edi, 5
  000f2	7c cc		 jl	 SHORT $LL18@primMST

; 69   : 	{
; 70   : 		// Pick the minimum key vertex from the
; 71   : 		// set of vertices not yet included in MST
; 72   : 		int u = minKey(key, mstSet);
; 73   : 
; 74   : 		// Add the picked vertex to the MST Set
; 75   : 		mstSet[u] = true;

  000f4	4b 8d 14 80	 lea	 rdx, QWORD PTR [r8+r8*4]
  000f8	46 88 74 05 1f	 mov	 BYTE PTR mstSet$[rbp+r8-73], r14b

; 76   : 
; 77   : 		// Update key value and parent index of
; 78   : 		// the adjacent vertices of the picked vertex.
; 79   : 		// Consider only those vertices which are not
; 80   : 		// yet included in MST
; 81   : 		for (int v = 0; v < V; v++)
; 82   : 
; 83   : 			// graph[u][v] is non zero only for adjacent vertices of m
; 84   : 			// mstSet[v] is false for vertices not yet included in MST
; 85   : 			// Update the key only if graph[u][v] is smaller than key[v]
; 86   : 			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])

  000fd	41 8b 04 97	 mov	 eax, DWORD PTR [r15+rdx*4]
  00101	85 c0		 test	 eax, eax
  00103	74 14		 je	 SHORT $LN8@primMST
  00105	80 7d 1f 00	 cmp	 BYTE PTR mstSet$[rbp-73], 0
  00109	75 0e		 jne	 SHORT $LN8@primMST
  0010b	41 3b c5	 cmp	 eax, r13d
  0010e	7d 09		 jge	 SHORT $LN8@primMST

; 87   : 				parent[v] = u, key[v] = graph[u][v];

  00110	89 4d 07	 mov	 DWORD PTR parent$[rbp-73], ecx
  00113	44 8b e8	 mov	 r13d, eax
  00116	89 45 ef	 mov	 DWORD PTR key$[rbp-73], eax
$LN8@primMST:

; 76   : 
; 77   : 		// Update key value and parent index of
; 78   : 		// the adjacent vertices of the picked vertex.
; 79   : 		// Consider only those vertices which are not
; 80   : 		// yet included in MST
; 81   : 		for (int v = 0; v < V; v++)
; 82   : 
; 83   : 			// graph[u][v] is non zero only for adjacent vertices of m
; 84   : 			// mstSet[v] is false for vertices not yet included in MST
; 85   : 			// Update the key only if graph[u][v] is smaller than key[v]
; 86   : 			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])

  00119	41 8b 44 97 04	 mov	 eax, DWORD PTR [r15+rdx*4+4]
  0011e	85 c0		 test	 eax, eax
  00120	74 14		 je	 SHORT $LN37@primMST
  00122	80 7d 20 00	 cmp	 BYTE PTR mstSet$[rbp-72], 0
  00126	75 0e		 jne	 SHORT $LN37@primMST
  00128	3b 45 db	 cmp	 eax, DWORD PTR key$2$[rbp-73]
  0012b	7d 09		 jge	 SHORT $LN37@primMST

; 87   : 				parent[v] = u, key[v] = graph[u][v];

  0012d	89 4d 0b	 mov	 DWORD PTR parent$[rbp-69], ecx
  00130	89 45 db	 mov	 DWORD PTR key$2$[rbp-73], eax
  00133	89 45 f3	 mov	 DWORD PTR key$[rbp-69], eax
$LN37@primMST:

; 76   : 
; 77   : 		// Update key value and parent index of
; 78   : 		// the adjacent vertices of the picked vertex.
; 79   : 		// Consider only those vertices which are not
; 80   : 		// yet included in MST
; 81   : 		for (int v = 0; v < V; v++)
; 82   : 
; 83   : 			// graph[u][v] is non zero only for adjacent vertices of m
; 84   : 			// mstSet[v] is false for vertices not yet included in MST
; 85   : 			// Update the key only if graph[u][v] is smaller than key[v]
; 86   : 			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])

  00136	41 8b 44 97 08	 mov	 eax, DWORD PTR [r15+rdx*4+8]
  0013b	85 c0		 test	 eax, eax
  0013d	74 14		 je	 SHORT $LN39@primMST
  0013f	80 7d 21 00	 cmp	 BYTE PTR mstSet$[rbp-71], 0
  00143	75 0e		 jne	 SHORT $LN39@primMST
  00145	3b 45 df	 cmp	 eax, DWORD PTR key$3$[rbp-73]
  00148	7d 09		 jge	 SHORT $LN39@primMST

; 87   : 				parent[v] = u, key[v] = graph[u][v];

  0014a	89 4d 0f	 mov	 DWORD PTR parent$[rbp-65], ecx
  0014d	89 45 df	 mov	 DWORD PTR key$3$[rbp-73], eax
  00150	89 45 f7	 mov	 DWORD PTR key$[rbp-65], eax
$LN39@primMST:

; 76   : 
; 77   : 		// Update key value and parent index of
; 78   : 		// the adjacent vertices of the picked vertex.
; 79   : 		// Consider only those vertices which are not
; 80   : 		// yet included in MST
; 81   : 		for (int v = 0; v < V; v++)
; 82   : 
; 83   : 			// graph[u][v] is non zero only for adjacent vertices of m
; 84   : 			// mstSet[v] is false for vertices not yet included in MST
; 85   : 			// Update the key only if graph[u][v] is smaller than key[v]
; 86   : 			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])

  00153	41 8b 44 97 0c	 mov	 eax, DWORD PTR [r15+rdx*4+12]
  00158	85 c0		 test	 eax, eax
  0015a	74 14		 je	 SHORT $LN41@primMST
  0015c	80 7d 22 00	 cmp	 BYTE PTR mstSet$[rbp-70], 0
  00160	75 0e		 jne	 SHORT $LN41@primMST
  00162	3b 45 d7	 cmp	 eax, DWORD PTR key$4$[rbp-73]
  00165	7d 09		 jge	 SHORT $LN41@primMST

; 87   : 				parent[v] = u, key[v] = graph[u][v];

  00167	89 4d 13	 mov	 DWORD PTR parent$[rbp-61], ecx
  0016a	89 45 d7	 mov	 DWORD PTR key$4$[rbp-73], eax
  0016d	89 45 fb	 mov	 DWORD PTR key$[rbp-61], eax
$LN41@primMST:

; 76   : 
; 77   : 		// Update key value and parent index of
; 78   : 		// the adjacent vertices of the picked vertex.
; 79   : 		// Consider only those vertices which are not
; 80   : 		// yet included in MST
; 81   : 		for (int v = 0; v < V; v++)
; 82   : 
; 83   : 			// graph[u][v] is non zero only for adjacent vertices of m
; 84   : 			// mstSet[v] is false for vertices not yet included in MST
; 85   : 			// Update the key only if graph[u][v] is smaller than key[v]
; 86   : 			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])

  00170	41 8b 44 97 10	 mov	 eax, DWORD PTR [r15+rdx*4+16]
  00175	85 c0		 test	 eax, eax
  00177	74 14		 je	 SHORT $LN43@primMST
  00179	80 7d 23 00	 cmp	 BYTE PTR mstSet$[rbp-69], 0
  0017d	75 0e		 jne	 SHORT $LN43@primMST
  0017f	41 3b c4	 cmp	 eax, r12d
  00182	7d 09		 jge	 SHORT $LN43@primMST

; 87   : 				parent[v] = u, key[v] = graph[u][v];

  00184	89 4d 17	 mov	 DWORD PTR parent$[rbp-57], ecx
  00187	44 8b e0	 mov	 r12d, eax
  0018a	89 45 ff	 mov	 DWORD PTR key$[rbp-57], eax
$LN43@primMST:

; 66   : 
; 67   : 	// The MST will have V vertices
; 68   : 	for (int count = 0; count < V - 1; count++)

  0018d	4c 29 75 e7	 sub	 QWORD PTR tv1121[rbp-73], r14
  00191	0f 85 19 ff ff
	ff		 jne	 $LL7@primMST

; 39   : 	std::cout<<"Edge \tWeight\n";

  00197	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0019e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@GOKCDOKC@Edge?5?7Weight?6@
  001a5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  001aa	4c 8b ac 24 88
	00 00 00	 mov	 r13, QWORD PTR [rsp+136]
  001b2	48 8d 75 0b	 lea	 rsi, QWORD PTR parent$[rbp-69]
  001b6	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR [rsp+144]
  001be	bf 05 00 00 00	 mov	 edi, 5
  001c3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL24@primMST:

; 41   : 		std::cout<<parent[i]<<" - "<<i<<" \t"<<graph[i][parent[i]]<<" \n";

  001d0	48 63 16	 movsxd	 rdx, DWORD PTR [rsi]
  001d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001da	48 8d 1c 17	 lea	 rbx, QWORD PTR [rdi+rdx]
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  001e4	48 8b c8	 mov	 rcx, rax
  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NLJIHOMM@?5?9?5@
  001ee	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	41 8b d6	 mov	 edx, r14d
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  001ff	48 8b c8	 mov	 rcx, rax
  00202	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02OJDBNLEE@?5?7@
  00209	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0020e	41 8b 14 9f	 mov	 edx, DWORD PTR [r15+rbx*4]
  00212	48 8b c8	 mov	 rcx, rax
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0021b	48 8b c8	 mov	 rcx, rax
  0021e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCBMIIIH@?5?6@
  00225	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0022a	41 ff c6	 inc	 r14d
  0022d	48 8d 76 04	 lea	 rsi, QWORD PTR [rsi+4]
  00231	48 8d 7f 05	 lea	 rdi, QWORD PTR [rdi+5]
  00235	41 83 fe 05	 cmp	 r14d, 5
  00239	7c 95		 jl	 SHORT $LL24@primMST

; 40   : 	for (int i = 1; i < V; i++)

  0023b	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR [rsp+128]
  00243	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+200]
  0024b	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+192]
  00253	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+184]

; 88   : 	}
; 89   : 
; 90   : 	// print the constructed MST
; 91   : 	printMST(parent, graph);
; 92   : }

  0025b	48 8b 4d 27	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-73]
  0025f	48 33 cc	 xor	 rcx, rsp
  00262	e8 00 00 00 00	 call	 __security_check_cookie
  00267	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0026e	41 5f		 pop	 r15
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
$LN13@primMST:

; 49   : 	// Array to store constructed MST
; 50   : 	int parent[V];
; 51   : 	
; 52   : 	// Key values used to pick minimum weight edge in cut
; 53   : 	int key[V];
; 54   : 	
; 55   : 	// To represent set of vertices included in MST
; 56   : 	bool mstSet[V];
; 57   : 
; 58   : 	// Initialize all keys as INFINITE
; 59   : 	for (int i = 0; i < V; i++)
; 60   : 		key[i] = INT_MAX, mstSet[i] = false;

  00272	e8 00 00 00 00	 call	 __report_rangecheckfailure
  00277	cc		 int	 3
$LN54@primMST:
?primMST@@YAXQEAY04H@Z ENDP				; primMST
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 734  :     const char* _Val) { // insert NTBS into char stream

$LN99:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	4c 8b fa	 mov	 r15, rdx
  00019	48 8b f1	 mov	 rsi, rcx

; 735  :     using _Elem = char;
; 736  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 737  : 
; 738  :     ios_base::iostate _State = ios_base::goodbit;

  0001c	33 db		 xor	 ebx, ebx
  0001e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	49 c7 c6 ff ff
	ff ff		 mov	 r14, -1
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL92@operator:
  00030	49 ff c6	 inc	 r14
  00033	42 38 1c 32	 cmp	 BYTE PTR [rdx+r14], bl
  00037	75 f7		 jne	 SHORT $LL92@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 363  :         return _Wide;

  00040	48 8b 7c 30 28	 mov	 rdi, QWORD PTR [rax+rsi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00045	48 85 ff	 test	 rdi, rdi
  00048	7e 0a		 jle	 SHORT $LN17@operator
  0004a	49 3b fe	 cmp	 rdi, r14
  0004d	7e 05		 jle	 SHORT $LN17@operator
  0004f	49 2b fe	 sub	 rdi, r14
  00052	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00054	33 ff		 xor	 edi, edi
$LN18@operator:

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00056	4c 8b e6	 mov	 r12, rsi
  00059	48 89 74 24 20	 mov	 QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  0005e	4c 8b 44 30 48	 mov	 r8, QWORD PTR [rax+rsi+72]
  00063	48 8b d1	 mov	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 73   :             if (_Rdbuf) {

  00066	4d 85 c0	 test	 r8, r8
  00069	74 0f		 je	 SHORT $LN39@operator

; 74   :                 _Rdbuf->_Lock();

  0006b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0006e	49 8b c8	 mov	 rcx, r8
  00071	ff 50 08	 call	 QWORD PTR [rax+8]
  00074	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00077	48 8b d1	 mov	 rdx, rcx
$LN39@operator:

; 93   :             if (!_Ostr.good()) {

  0007a	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0007e	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 93   :             if (!_Ostr.good()) {

  00083	74 04		 je	 SHORT $LN33@operator

; 94   :                 _Ok = false;

  00085	32 c0		 xor	 al, al

; 95   :                 return;

  00087	eb 2e		 jmp	 SHORT $LN95@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 70   :         return _Tiestr;

  00089	48 8b 44 30 50	 mov	 rax, QWORD PTR [rax+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0008e	48 85 c0	 test	 rax, rax
  00091	74 22		 je	 SHORT $LN35@operator
  00093	48 3b c6	 cmp	 rax, rsi
  00096	74 1d		 je	 SHORT $LN35@operator

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  :             _Tied->flush();

  00098	48 8b c8	 mov	 rcx, rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000a1	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000a4	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  000a8	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
  000ad	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000b0	48 8b d1	 mov	 rdx, rcx
  000b3	eb 02		 jmp	 SHORT $LN95@operator
$LN35@operator:

; 100  :                 _Ok = true;

  000b5	b0 01		 mov	 al, 1
$LN95@operator:

; 106  :         }

  000b7	88 44 24 28	 mov	 BYTE PTR _Ok$[rsp+8], al

; 741  :     const typename _Myos::sentry _Ok(_Ostr);
; 742  : 
; 743  :     if (!_Ok) {

  000bb	84 c0		 test	 al, al
  000bd	75 0a		 jne	 SHORT $LN8@operator

; 744  :         _State |= ios_base::badbit;

  000bf	bb 04 00 00 00	 mov	 ebx, 4

; 745  :     } else { // state okay, insert

  000c4	e9 a9 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000c9	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 326  :         return _Fmtfl;

  000cd	8b 4c 30 18	 mov	 ecx, DWORD PTR [rax+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000d1	81 e1 c0 01 00
	00		 and	 ecx, 448		; 000001c0H
  000d7	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000da	74 2d		 je	 SHORT $LN87@operator
  000dc	0f 1f 40 00	 npad	 4
$LL4@operator:

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000e0	48 85 ff	 test	 rdi, rdi
  000e3	7e 21		 jle	 SHORT $LN89@operator

; 749  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000e5	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000e8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000ec	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000f1	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000fc	83 f8 ff	 cmp	 eax, -1
  000ff	74 48		 je	 SHORT $LN96@operator

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00101	48 ff cf	 dec	 rdi
  00104	eb da		 jmp	 SHORT $LL4@operator
$LN89@operator:

; 750  :                     _State |= ios_base::badbit; // insertion failed, quit
; 751  :                     break;
; 752  :                 }
; 753  :             }
; 754  :         }
; 755  : 
; 756  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00106	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN87@operator:
  00109	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  0010d	4d 8b c6	 mov	 r8, r14
  00110	49 8b d7	 mov	 rdx, r15
  00113	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  0011e	49 3b c6	 cmp	 rax, r14
  00121	75 26		 jne	 SHORT $LN96@operator
$LL93@operator:

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00123	48 85 ff	 test	 rdi, rdi
  00126	7e 2a		 jle	 SHORT $LN6@operator

; 762  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00128	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0012b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012f	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00134	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	74 05		 je	 SHORT $LN96@operator

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00144	48 ff cf	 dec	 rdi
  00147	eb da		 jmp	 SHORT $LL93@operator
$LN96@operator:

; 763  :                     _State |= ios_base::badbit; // insertion failed, quit
; 764  :                     break;
; 765  :                 }
; 766  :             }
; 767  :         }
; 768  : 
; 769  :         _Ostr.width(0);

  00149	bb 04 00 00 00	 mov	 ebx, 4
  0014e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
$LN6@operator:
  00152	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00155	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00159	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
  00162	eb 0e		 jmp	 SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
  00164	48 8b 74 24 60	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00169	8b 5c 24 70	 mov	 ebx, DWORD PTR _State$[rsp]
  0016d	4c 8b 64 24 20	 mov	 r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 773  :     _Ostr.setstate(_State);

  00172	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00175	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00179	48 03 ce	 add	 rcx, rsi
  0017c	45 33 c0	 xor	 r8d, r8d
  0017f	8b d3		 mov	 edx, ebx
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00187	90		 npad	 1

; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00188	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0018d	84 c0		 test	 al, al
  0018f	75 0a		 jne	 SHORT $LN72@operator

; 119  :                 this->_Myostr._Osfx();

  00191	49 8b cc	 mov	 rcx, r12
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0019a	90		 npad	 1
$LN72@operator:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0019b	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0019f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  001a3	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  001a8	48 85 c9	 test	 rcx, rcx
  001ab	74 07		 je	 SHORT $LN76@operator

; 81   :                 _Rdbuf->_Unlock();

  001ad	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b0	ff 50 10	 call	 QWORD PTR [rax+16]
  001b3	90		 npad	 1
$LN76@operator:

; 774  :     return _Ostr;

  001b4	48 8b c6	 mov	 rax, rsi

; 775  : }

  001b7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c0	41 5f		 pop	 r15
  001c2	41 5e		 pop	 r14
  001c4	41 5c		 pop	 r12
  001c6	5f		 pop	 rdi
  001c7	5e		 pop	 rsi
  001c8	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\spanning_tree.cpp
;	COMDAT ?printMST@@YAXQEAHQEAY04H@Z
_TEXT	SEGMENT
parent$ = 48
graph$ = 56
?printMST@@YAXQEAHQEAY04H@Z PROC			; printMST, COMDAT

; 38   : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00014	41 57		 push	 r15
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	4c 8b fa	 mov	 r15, rdx
  0001d	4c 8b f1	 mov	 r14, rcx

; 39   : 	std::cout<<"Edge \tWeight\n";

  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@GOKCDOKC@Edge?5?7Weight?6@
  0002e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00033	49 83 c6 04	 add	 r14, 4
  00037	bf 01 00 00 00	 mov	 edi, 1
  0003c	be 05 00 00 00	 mov	 esi, 5
$LL4@printMST:

; 40   : 	for (int i = 1; i < V; i++)
; 41   : 		std::cout<<parent[i]<<" - "<<i<<" \t"<<graph[i][parent[i]]<<" \n";

  00041	49 63 16	 movsxd	 rdx, DWORD PTR [r14]
  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0004b	48 8d 1c 16	 lea	 rbx, QWORD PTR [rsi+rdx]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00055	48 8b c8	 mov	 rcx, rax
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NLJIHOMM@?5?9?5@
  0005f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00064	48 8b c8	 mov	 rcx, rax
  00067	8b d7		 mov	 edx, edi
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0006f	48 8b c8	 mov	 rcx, rax
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02OJDBNLEE@?5?7@
  00079	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0007e	41 8b 14 9f	 mov	 edx, DWORD PTR [r15+rbx*4]
  00082	48 8b c8	 mov	 rcx, rax
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCBMIIIH@?5?6@
  00095	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0009a	ff c7		 inc	 edi
  0009c	4d 8d 76 04	 lea	 r14, QWORD PTR [r14+4]
  000a0	48 8d 76 05	 lea	 rsi, QWORD PTR [rsi+5]
  000a4	83 ff 05	 cmp	 edi, 5
  000a7	7c 98		 jl	 SHORT $LL4@printMST

; 42   : }

  000a9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ae	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b3	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000b8	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  000bd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c1	41 5f		 pop	 r15
  000c3	c3		 ret	 0
?printMST@@YAXQEAHQEAY04H@Z ENDP			; printMST
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\spanning_tree.cpp
;	COMDAT ?minKey@@YAHQEAHQEA_N@Z
_TEXT	SEGMENT
key$ = 48
mstSet$ = 56
min_index$ = 64
?minKey@@YAHQEAHQEA_N@Z PROC				; minKey, COMDAT

; 17   : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 8b f2	 mov	 rsi, rdx

; 18   : 	// Initialize min value
; 19   : 	int min = INT_MAX, min_index;
; 20   : 
; 21   : 	for (int v = 0; v < V; v++)

  00015	8b 4c 24 40	 mov	 ecx, DWORD PTR min_index$[rsp]
  00019	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0001e	33 ff		 xor	 edi, edi
$LL4@minKey:

; 22   : 		if (mstSet[v] == false && key[v] < min)

  00020	80 3e 00	 cmp	 BYTE PTR [rsi], 0
  00023	75 1f		 jne	 SHORT $LN2@minKey
  00025	39 03		 cmp	 DWORD PTR [rbx], eax
  00027	7d 1b		 jge	 SHORT $LN2@minKey

; 23   : 		{
; 24   : 			printf("vor crash:\n");

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@IJPENPOG@vor?5crash?3?6@
  00030	e8 00 00 00 00	 call	 printf

; 25   : 
; 26   : 			min = key[v], min_index = v;

  00035	8b 03		 mov	 eax, DWORD PTR [rbx]
  00037	8b cf		 mov	 ecx, edi

; 27   : 			volatile int* a = reinterpret_cast<volatile int*>(NULL);
; 28   : 			*a = 1;//TEST crash: write acces violation

  00039	c7 04 25 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ds:0, 1
$LN2@minKey:

; 18   : 	// Initialize min value
; 19   : 	int min = INT_MAX, min_index;
; 20   : 
; 21   : 	for (int v = 0; v < V; v++)

  00044	ff c7		 inc	 edi
  00046	48 ff c6	 inc	 rsi
  00049	48 83 c3 04	 add	 rbx, 4
  0004d	83 ff 05	 cmp	 edi, 5
  00050	7c ce		 jl	 SHORT $LL4@minKey

; 29   : 			
; 30   : 		}
; 31   : 
; 32   : 	return min_index;
; 33   : }

  00052	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00057	8b c1		 mov	 eax, ecx
  00059	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
?minKey@@YAHQEAHQEA_N@Z ENDP				; minKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\dynamic_library\spanning_tree.cpp
;	COMDAT ?calc_mininum_spaning@@YAXXZ
_TEXT	SEGMENT
graph$ = 32
__$ArrayPad$ = 144
?calc_mininum_spaning@@YAXXZ PROC			; calc_mininum_spaning, COMDAT

; 96   : {

$LN4:
  00000	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 97   : 	/* Let us create the following graph
; 98   : 		2 3
; 99   : 	(0)--(1)--(2)
; 100  : 	| / \ |
; 101  : 	6| 8/ \5 |7
; 102  : 	| / \ |
; 103  : 	(3)-------(4)
; 104  : 			9	 */
; 105  : 	int graph[V][V] = { { 0, 2, 0, 6, 0 },

  00019	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000006000000000000000200000000

; 106  : 						{ 2, 0, 3, 8, 5 },
; 107  : 						{ 0, 3, 0, 0, 7 },
; 108  : 						{ 6, 8, 0, 0, 9 },
; 109  : 						{ 0, 5, 7, 9, 0 } };
; 110  : 
; 111  : 	// Print the solution
; 112  : 	primMST(graph);

  00021	48 8d 4c 24 20	 lea	 rcx, QWORD PTR graph$[rsp]
  00026	66 0f 6f 0d 00
	00 00 00	 movdqa	 xmm1, XMMWORD PTR __xmm@00000003000000000000000200000000
  0002e	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR graph$[rsp], xmm0
  00034	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000003000000000000000500000008
  0003c	66 0f 7f 4c 24
	30		 movdqa	 XMMWORD PTR graph$[rsp+16], xmm1
  00042	66 0f 6f 0d 00
	00 00 00	 movdqa	 xmm1, XMMWORD PTR __xmm@00000006000000070000000000000000
  0004a	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR graph$[rsp+32], xmm0
  00050	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000009000000000000000000000008
  00058	66 0f 7f 4c 24
	50		 movdqa	 XMMWORD PTR graph$[rsp+48], xmm1
  0005e	66 0f 6f 0d 00
	00 00 00	 movdqa	 xmm1, XMMWORD PTR __xmm@00000009000000070000000500000000
  00066	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR graph$[rsp+64], xmm0
  0006c	66 0f 7f 4c 24
	70		 movdqa	 XMMWORD PTR graph$[rsp+80], xmm1
  00072	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR graph$[rsp+96], 0
  0007d	e8 00 00 00 00	 call	 ?primMST@@YAXQEAY04H@Z	; primMST

; 113  : 
; 114  : }

  00082	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008a	48 33 cc	 xor	 rcx, rsp
  0008d	e8 00 00 00 00	 call	 __security_check_cookie
  00092	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00099	c3		 ret	 0
?calc_mininum_spaning@@YAXXZ ENDP			; calc_mininum_spaning
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 956  :     {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	53		 push	 rbx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001b	48 8b f9	 mov	 rdi, rcx

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  0001e	48 8d 74 24 58	 lea	 rsi, QWORD PTR _Format$[rsp+8]

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00023	b9 01 00 00 00	 mov	 ecx, 1
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002e	48 8b d8	 mov	 rbx, rax

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00031	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00036	45 33 c9	 xor	 r9d, r9d
  00039	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0003e	4c 8b c7	 mov	 r8, rdi
  00041	48 8b d3	 mov	 rdx, rbx
  00044	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;
; 963  :     }

  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi
  00052	5e		 pop	 rsi
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
