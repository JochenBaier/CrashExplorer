; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30038.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?search@pattern_searcher_t@@QEAAHXZ		; pattern_searcher_t::search
PUBLIC	?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; pattern_searcher_t::buildMatchingMachine
PUBLIC	?findNextState@pattern_searcher_t@@AEAAHHD@Z	; pattern_searcher_t::findNextState
PUBLIC	?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z ; pattern_searcher_t::searchWords
PUBLIC	??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >
PUBLIC	?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ ; std::deque<int,std::allocator<int> >::_Xlen
PUBLIC	?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::deque<int,std::allocator<int> >::_Growmap
PUBLIC	??1?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ ; std::queue<int,std::deque<int,std::allocator<int> > >::~queue<int,std::deque<int,std::allocator<int> > >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$uninitialized_copy@PEAPEAHPEAPEAH@std@@YAPEAPEAHQEAPEAH0PEAPEAH@Z ; std::uninitialized_copy<int * *,int * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PEAPEAH_K@std@@YAPEAPEAHPEAPEAH_K@Z ; std::_Uninitialized_value_construct_n_unchecked1<int * *,unsigned __int64>
PUBLIC	??$_Zero_range@PEAPEAH@std@@YAPEAPEAHQEAPEAH0@Z	; std::_Zero_range<int * *>
PUBLIC	??$_Copy_memmove@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAH00@Z ; std::_Copy_memmove<int * *,int * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_04MKEOLIJC@?5to?5@			; `string'
PUBLIC	??_C@_0P@OIGFIEEN@?5appears?5from?5@		; `string'
PUBLIC	??_C@_05FPLIKJMG@Word?5@			; `string'
PUBLIC	??_C@_03PJHPCKOL@she@				; `string'
PUBLIC	??_C@_03GDDNCFJF@his@				; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__std_terminate:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_K@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+66
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+60
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+60
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+66
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+43
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+23
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+23
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN27
	DD	imagerel $LN27+89
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN54
	DD	imagerel $LN54+221
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN20
	DD	imagerel $LN20+56
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN44
	DD	imagerel $LN44+230
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN30
	DD	imagerel $LN30+95
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN79
	DD	imagerel $LN79+91
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN79+91
	DD	imagerel $LN79+308
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN79+308
	DD	imagerel $LN79+330
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN79+330
	DD	imagerel $LN79+337
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN79+337
	DD	imagerel $LN79+343
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN79+343
	DD	imagerel $LN79+349
	DD	imagerel $chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN27
	DD	imagerel $LN27+95
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?search@pattern_searcher_t@@QEAAHXZ DD imagerel $LN525
	DD	imagerel $LN525+305
	DD	imagerel $unwind$?search@pattern_searcher_t@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA DD imagerel ?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA
	DD	imagerel ?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA+42
	DD	imagerel $unwind$?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD imagerel $LN327
	DD	imagerel $LN327+1196
	DD	imagerel $unwind$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z DD imagerel $LN75
	DD	imagerel $LN75+583
	DD	imagerel $unwind$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z DD imagerel $LN30
	DD	imagerel $LN30+112
	DD	imagerel $unwind$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAH@std@@QEAAXQEAPEAH_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAH@std@@QEAAXQEAPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAH@std@@QEAAPEAPEAH_K@Z DD imagerel $LN30
	DD	imagerel $LN30+112
	DD	imagerel $unwind$?allocate@?$allocator@PEAH@std@@QEAAPEAPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ DD imagerel $LN46
	DD	imagerel $LN46+66
	DD	imagerel $unwind$??0?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ DD imagerel $LN93
	DD	imagerel $LN93+196
	DD	imagerel $unwind$??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z DD imagerel $LN42
	DD	imagerel $LN42+197
	DD	imagerel $unwind$?push_back@?$deque@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN150+73
	DD	imagerel $LN150+193
	DD	imagerel $chain$1$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN150+193
	DD	imagerel $LN150+380
	DD	imagerel $chain$4$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN150+380
	DD	imagerel $LN150+451
	DD	imagerel $chain$5$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN150+451
	DD	imagerel $LN150+464
	DD	imagerel $chain$7$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN150+464
	DD	imagerel $LN150+473
	DD	imagerel $chain$8$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$deque@HV?$allocator@H@std@@@std@@AEAAXXZ DD imagerel $LN65
	DD	imagerel $LN65+184
	DD	imagerel $unwind$?_Tidy@?$deque@HV?$allocator@H@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+66
	DD	imagerel $unwind$??0?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push@?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAAXAEBH@Z DD imagerel $LN45
	DD	imagerel $LN45+197
	DD	imagerel $unwind$?push@?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN99
	DD	imagerel $LN99+457
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+108
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN37
	DD	imagerel $LN37+39
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN24
	DD	imagerel $LN24+122
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+61
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_internal@AEBH@?$deque@HV?$allocator@H@std@@@std@@AEAAXAEBH@Z DD imagerel $LN39
	DD	imagerel $LN39+197
	DD	imagerel $unwind$??$_Emplace_back_internal@AEBH@?$deque@HV?$allocator@H@std@@@std@@AEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+42
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN68
	DD	imagerel $LN68+41
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN68+41
	DD	imagerel $LN68+290
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN68+290
	DD	imagerel $LN68+297
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN68+297
	DD	imagerel $LN68+303
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN68+303
	DD	imagerel $LN68+309
	DD	imagerel $chain$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN18
	DD	imagerel $LN18+53
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN99
	DD	imagerel $LN99+446
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+37
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_copy@PEAPEAHPEAPEAH@std@@YAPEAPEAHQEAPEAH0PEAPEAH@Z DD imagerel $LN20
	DD	imagerel $LN20+48
	DD	imagerel $unwind$??$uninitialized_copy@PEAPEAHPEAPEAH@std@@YAPEAPEAHQEAPEAH0PEAPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAH_K@std@@YAPEAPEAHPEAPEAH_K@Z DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAH_K@std@@YAPEAPEAHPEAPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$03@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$03@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+66
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_unchecked@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAHQEAPEAH0@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Uninitialized_copy_unchecked@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAHQEAPEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAPEAH@std@@YAPEAPEAHQEAPEAH0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAPEAH@std@@YAPEAPEAHQEAPEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAH00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAH00@Z
pdata	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GDDNCFJF@his@
CONST	SEGMENT
??_C@_03GDDNCFJF@his@ DB 'his', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHPCKOL@she@
CONST	SEGMENT
??_C@_03PJHPCKOL@she@ DB 'she', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPLIKJMG@Word?5@
CONST	SEGMENT
??_C@_05FPLIKJMG@Word?5@ DB 'Word ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OIGFIEEN@?5appears?5from?5@
CONST	SEGMENT
??_C@_0P@OIGFIEEN@?5appears?5from?5@ DB ' appears from ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKEOLIJC@?5to?5@
CONST	SEGMENT
??_C@_04MKEOLIJC@?5to?5@ DB ' to ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAH00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAPEAH@std@@YAPEAPEAHQEAPEAH0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_unchecked@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAHQEAPEAH0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$03@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAH_K@std@@YAPEAPEAHPEAPEAH_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_copy@PEAPEAHPEAPEAH@std@@YAPEAPEAHQEAPEAH0PEAPEAH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 010H
	DB	0baH
	DB	00H
	DB	'T'
	DB	02H
	DB	0aeH
	DB	06H
	DB	098H
	DB	04H
	DB	'2'
	DB	06H
	DB	'h'
	DB	04H
	DB	'&'
	DB	0aH
	DB	'6'
	DB	0cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DB	'i', 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0cH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __std_terminate
	DB	02eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040021H
	DD	09e400H
	DD	087400H
	DD	imagerel $LN68
	DD	imagerel $LN68+41
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 021H
	DD	imagerel $LN68
	DD	imagerel $LN68+41
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040021H
	DD	09e400H
	DD	087400H
	DD	imagerel $LN68
	DD	imagerel $LN68+41
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040a21H
	DD	09e40aH
	DD	087405H
	DD	imagerel $LN68
	DD	imagerel $LN68+41
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 060d01H
	DD	0a340dH
	DD	0f009320dH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_internal@AEBH@?$deque@HV?$allocator@H@std@@@std@@AEAAXAEBH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 04H
	DB	'*'
	DB	00H
	DB	'<'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0eH
	DB	0e2H
	DB	00H
	DB	'T'
	DB	02H
	DB	0b6H
	DB	06H
	DB	0d8H
	DB	04H
	DB	'L'
	DB	0aH
	DB	'&'
	DB	0cH
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	091H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __std_terminate
	DB	02eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push@?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAAXAEBH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$deque@HV?$allocator@H@std@@@std@@AEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 040021H
	DD	04f400H
	DD	0be400H
	DD	imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN150+73
	DD	imagerel $LN150+193
	DD	imagerel $chain$1$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 061721H
	DD	0ac417H
	DD	09740eH
	DD	083405H
	DD	imagerel $LN150+73
	DD	imagerel $LN150+193
	DD	imagerel $chain$1$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 041421H
	DD	04f414H
	DD	0be405H
	DD	imagerel $LN150
	DD	imagerel $LN150+73
	DD	imagerel $unwind$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 030701H
	DD	060034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAH@std@@QEAAPEAPEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAH@std@@QEAAXQEAPEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z DB 04H
	DB	086H
	DB	02H
	DB	'1', 06H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z DB 028H
	DD	imagerel $stateUnwindMap$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z
	DD	imagerel $ip2state$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z DD 0a2319H
	DD	0163414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 06H
	DB	'-', 05H
	DB	02H
	DB	0c4H
	DB	04H
	DB	0d5H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 04H
	DB	0eH
	DD	imagerel __std_terminate
	DB	032H
	DD	imagerel ??1?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	imagerel $ip2state$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 0c1f11H
	DD	013741fH
	DD	011641fH
	DD	010341fH
	DD	0f018921fH
	DD	0d014e016H
	DD	05010c012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?search@pattern_searcher_t@@QEAAHXZ DB 04H
	DB	0edH, 03H
	DB	0aH
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?search@pattern_searcher_t@@QEAAHXZ DB 0aH
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	0aeH
	DD	imagerel ?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?search@pattern_searcher_t@@QEAAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?search@pattern_searcher_t@@QEAAHXZ
	DD	imagerel $ip2state$?search@pattern_searcher_t@@QEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?search@pattern_searcher_t@@QEAAHXZ DD 031c19H
	DD	020010eH
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?search@pattern_searcher_t@@QEAAHXZ
	DD	0f2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020021H
	DD	08e400H
	DD	imagerel $LN79
	DD	imagerel $LN79+91
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+91
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020021H
	DD	08e400H
	DD	imagerel $LN79
	DD	imagerel $LN79+91
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+91
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	08e405H
	DD	imagerel $LN79
	DD	imagerel $LN79+91
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0f00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 085001H
	DD	065450H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 083501H
	DD	066435H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAH00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAH00@Z PROC ; std::_Copy_memmove<int * *,int * *>, COMDAT

; 4153 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8

; 4154 :     auto _FirstPtr              = _To_address(_First);
; 4155 :     auto _LastPtr               = _To_address(_Last);
; 4156 :     auto _DestPtr               = _To_address(_Dest);
; 4157 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4158 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4159 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4162 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 4164 :     } else {
; 4165 :         return _Dest + (_LastPtr - _FirstPtr);
; 4166 :     }
; 4167 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$_Copy_memmove@PEAPEAHPEAPEAH@std@@YAPEAPEAHPEAPEAH00@Z ENDP ; std::_Copy_memmove<int * *,int * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$_Zero_range@PEAPEAH@std@@YAPEAPEAHQEAPEAH0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAPEAH@std@@YAPEAPEAHQEAPEAH0@Z PROC	; std::_Zero_range<int * *>, COMDAT

; 1786 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1787 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1788 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00006	4c 8b c2	 mov	 r8, rdx
  00009	48 8b da	 mov	 rbx, rdx
  0000c	4c 2b c1	 sub	 r8, rcx
  0000f	33 d2		 xor	 edx, edx
  00011	e8 00 00 00 00	 call	 memset

; 1790 :     return _Last;

  00016	48 8b c3	 mov	 rax, rbx

; 1791 : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
??$_Zero_range@PEAPEAH@std@@YAPEAPEAHQEAPEAH0@Z ENDP	; std::_Zero_range<int * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PEAPEAH_K@std@@YAPEAPEAHPEAPEAH_K@Z
_TEXT	SEGMENT
_UFirst$ = 48
_Count$ = 56
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAH_K@std@@YAPEAPEAHPEAPEAH_K@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<int * *,unsigned __int64>, COMDAT

; 1818 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1819 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1820 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1821 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1822 :         return _Zero_range(_UFirst, _UFirst + _Count);

  0000a	48 8d 1c d5 00
	00 00 00	 lea	 rbx, QWORD PTR [rdx*8]
  00012	48 8b f9	 mov	 rdi, rcx

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00015	4c 8b c3	 mov	 r8, rbx
  00018	33 d2		 xor	 edx, edx
  0001a	e8 00 00 00 00	 call	 memset

; 1819 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1820 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1821 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1822 :         return _Zero_range(_UFirst, _UFirst + _Count);

  0001f	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 1823 :     } else {
; 1824 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 1825 :         for (; 0 < _Count; --_Count) {
; 1826 :             _Backout._Emplace_back();
; 1827 :         }
; 1828 : 
; 1829 :         return _Backout._Release();
; 1830 :     }
; 1831 : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAH_K@std@@YAPEAPEAHPEAPEAH_K@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<int * *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$uninitialized_copy@PEAPEAHPEAPEAH@std@@YAPEAPEAHQEAPEAH0PEAPEAH@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$uninitialized_copy@PEAPEAHPEAPEAH@std@@YAPEAPEAHQEAPEAH0PEAPEAH@Z PROC ; std::uninitialized_copy<int * *,int * *>, COMDAT

; 1680 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4162 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1688 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$uninitialized_copy@PEAPEAHPEAPEAH@std@@YAPEAPEAHQEAPEAH0PEAPEAH@Z ENDP ; std::uninitialized_copy<int * *,int * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00004	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

  00008	48 3b c1	 cmp	 rax, rcx
  0000b	76 28		 jbe	 SHORT $LN16@Allocate_m

; 85   :         return ::operator new(_Bytes);

  0000d	48 8b c8	 mov	 rcx, rax
  00010	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00015	48 8b c8	 mov	 rcx, rax

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00018	48 85 c0	 test	 rax, rax
  0001b	74 11		 je	 SHORT $LN7@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0001d	48 83 c0 27	 add	 rax, 39			; 00000027H
  00021	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00025	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 148  : #endif // _DEBUG
; 149  :     return _Ptr;
; 150  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN7@Allocate_m:

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00034	cc		 int	 3
$LN16@Allocate_m:

; 138  :         _Throw_bad_array_new_length(); // add overflow

  00035	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0003a	cc		 int	 3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 501  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN99:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	4d 8b f8	 mov	 r15, r8
  00019	4c 8b e2	 mov	 r12, rdx
  0001c	48 8b f1	 mov	 rsi, rcx

; 502  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 503  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 504  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

  0001f	33 db		 xor	 ebx, ebx
  00021	89 5c 24 78	 mov	 DWORD PTR _State$[rsp], ebx

; 507  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 363  :         return _Wide;

  0002c	48 8b 7c 30 28	 mov	 rdi, QWORD PTR [rax+rsi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 507  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  00031	48 85 ff	 test	 rdi, rdi
  00034	7e 0a		 jle	 SHORT $LN10@Insert_str
  00036	49 3b f8	 cmp	 rdi, r8
  00039	76 05		 jbe	 SHORT $LN10@Insert_str

; 509  :     } else {
; 510  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

  0003b	49 2b f8	 sub	 rdi, r8
  0003e	eb 02		 jmp	 SHORT $LN9@Insert_str
$LN10@Insert_str:

; 508  :         _Pad = 0;

  00040	33 ff		 xor	 edi, edi
$LN9@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00042	4c 8b f6	 mov	 r14, rsi
  00045	48 89 74 24 20	 mov	 QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  0004a	4c 8b 44 30 48	 mov	 r8, QWORD PTR [rax+rsi+72]
  0004f	48 8b d1	 mov	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 73   :             if (_Rdbuf) {

  00052	4d 85 c0	 test	 r8, r8
  00055	74 0f		 je	 SHORT $LN38@Insert_str

; 74   :                 _Rdbuf->_Lock();

  00057	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0005a	49 8b c8	 mov	 rcx, r8
  0005d	ff 50 08	 call	 QWORD PTR [rax+8]
  00060	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00063	48 8b d1	 mov	 rdx, rcx
$LN38@Insert_str:

; 93   :             if (!_Ostr.good()) {

  00066	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0006a	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 93   :             if (!_Ostr.good()) {

  0006f	74 04		 je	 SHORT $LN32@Insert_str

; 94   :                 _Ok = false;

  00071	32 c0		 xor	 al, al

; 95   :                 return;

  00073	eb 2e		 jmp	 SHORT $LN95@Insert_str
$LN32@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 70   :         return _Tiestr;

  00075	48 8b 44 30 50	 mov	 rax, QWORD PTR [rax+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0007a	48 85 c0	 test	 rax, rax
  0007d	74 22		 je	 SHORT $LN34@Insert_str
  0007f	48 3b c6	 cmp	 rax, rsi
  00082	74 1d		 je	 SHORT $LN34@Insert_str

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  :             _Tied->flush();

  00084	48 8b c8	 mov	 rcx, rax
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  0008d	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00090	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  00094	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
  00099	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  0009c	48 8b d1	 mov	 rdx, rcx
  0009f	eb 02		 jmp	 SHORT $LN95@Insert_str
$LN34@Insert_str:

; 100  :                 _Ok = true;

  000a1	b0 01		 mov	 al, 1
$LN95@Insert_str:

; 106  :         }

  000a3	88 44 24 28	 mov	 BYTE PTR _Ok$[rsp+8], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 515  :     if (!_Ok) {

  000a7	84 c0		 test	 al, al
  000a9	75 0a		 jne	 SHORT $LN11@Insert_str

; 516  :         _State |= _Ostr_t::badbit;

  000ab	bb 04 00 00 00	 mov	 ebx, 4

; 517  :     } else { // state okay, insert characters

  000b0	e9 b3 00 00 00	 jmp	 $LN23@Insert_str
$LN11@Insert_str:

; 519  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  000b5	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 326  :         return _Fmtfl;

  000b9	8b 4c 30 18	 mov	 ecx, DWORD PTR [rax+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 519  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  000bd	81 e1 c0 01 00
	00		 and	 ecx, 448		; 000001c0H
  000c3	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000c6	74 6c		 je	 SHORT $LN88@Insert_str
$LL4@Insert_str:

; 520  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000c8	48 85 ff	 test	 rdi, rdi
  000cb	74 64		 je	 SHORT $LN90@Insert_str

; 521  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000cd	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d0	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000d4	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000d9	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000e4	83 f8 ff	 cmp	 eax, -1
  000e7	75 43		 jne	 SHORT $LN2@Insert_str

; 522  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  000e9	bb 04 00 00 00	 mov	 ebx, 4
  000ee	89 5c 24 78	 mov	 DWORD PTR _State$[rsp], ebx
$LL93@Insert_str:

; 532  :             for (; 0 < _Pad; --_Pad) { // pad on right

  000f2	48 85 ff	 test	 rdi, rdi
  000f5	74 23		 je	 SHORT $LN6@Insert_str

; 533  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000f7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000fa	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000fe	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00103	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0010e	83 f8 ff	 cmp	 eax, -1
  00111	75 42		 jne	 SHORT $LN5@Insert_str

; 534  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  00113	83 cb 04	 or	 ebx, 4
$LN96@Insert_str:

; 535  :                     break;
; 536  :                 }
; 537  :             }
; 538  :         }
; 539  : 
; 540  :         _Ostr.width(0);

  00116	89 5c 24 78	 mov	 DWORD PTR _State$[rsp], ebx
$LN6@Insert_str:
  0011a	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0011d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00121	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
  0012a	eb 3c		 jmp	 SHORT $LN23@Insert_str
$LN2@Insert_str:

; 520  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0012c	48 ff cf	 dec	 rdi
  0012f	eb 97		 jmp	 SHORT $LL4@Insert_str
$LN90@Insert_str:

; 523  :                     break;
; 524  :                 }
; 525  :             }
; 526  :         }
; 527  : 
; 528  :         if (_State == _Ostr_t::goodbit
; 529  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  00131	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN88@Insert_str:
  00134	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  00138	4d 8b c7	 mov	 r8, r15
  0013b	49 8b d4	 mov	 rdx, r12
  0013e	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00149	49 3b c7	 cmp	 rax, r15
  0014c	74 a4		 je	 SHORT $LL93@Insert_str

; 530  :             _State |= _Ostr_t::badbit;

  0014e	bb 04 00 00 00	 mov	 ebx, 4

; 531  :         } else {

  00153	eb c1		 jmp	 SHORT $LN96@Insert_str
$LN5@Insert_str:

; 532  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00155	48 ff cf	 dec	 rdi
  00158	eb 98		 jmp	 SHORT $LL93@Insert_str
$LN24@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
  0015a	48 8b 74 24 60	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  0015f	8b 5c 24 78	 mov	 ebx, DWORD PTR _State$[rsp]
  00163	4c 8b 74 24 20	 mov	 r14, QWORD PTR _Ok$[rsp]
$LN23@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 541  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 542  :     }
; 543  : 
; 544  :     _Ostr.setstate(_State);

  00168	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0016b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0016f	48 03 ce	 add	 rcx, rsi
  00172	45 33 c0	 xor	 r8d, r8d
  00175	8b d3		 mov	 edx, ebx
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0017d	90		 npad	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  0017e	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  00183	84 c0		 test	 al, al
  00185	75 0a		 jne	 SHORT $LN71@Insert_str

; 119  :                 this->_Myostr._Osfx();

  00187	49 8b ce	 mov	 rcx, r14
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00190	90		 npad	 1
$LN71@Insert_str:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00191	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00194	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  00198	4a 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+r14+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  0019d	48 85 c9	 test	 rcx, rcx
  001a0	74 07		 je	 SHORT $LN75@Insert_str

; 81   :                 _Rdbuf->_Unlock();

  001a2	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001a5	ff 50 10	 call	 QWORD PTR [rax+16]
  001a8	90		 npad	 1
$LN75@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 545  :     return _Ostr;

  001a9	48 8b c6	 mov	 rax, rsi

; 546  : }

  001ac	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b5	41 5f		 pop	 r15
  001b7	41 5e		 pop	 r14
  001b9	41 5c		 pop	 r12
  001bb	5f		 pop	 rdi
  001bc	5e		 pop	 rsi
  001bd	c3		 ret	 0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$4

; 541  :         _CATCH_IO_(_Ostr_t, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$4

; 541  :         _CATCH_IO_(_Ostr_t, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00009	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0000e	84 c0		 test	 al, al
  00010	75 0a		 jne	 SHORT $LN2@sentry

; 119  :                 this->_Myostr._Osfx();

  00012	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	90		 npad	 1
$LN2@sentry:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001c	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0001f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  00026	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  0002b	48 85 c9	 test	 rcx, rcx
  0002e	74 07		 je	 SHORT $LN10@sentry

; 81   :                 _Rdbuf->_Unlock();

  00030	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00033	ff 50 10	 call	 QWORD PTR [rax+16]
  00036	90		 npad	 1
$LN10@sentry:

; 120  :             }
; 121  :         }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00004	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00007	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  0000e	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	74 07		 je	 SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	ff 50 10	 call	 QWORD PTR [rax+16]
  0001e	90		 npad	 1
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 978  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 979  :     _Ostr.put(_Ostr.widen('\n'));

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	b2 0a		 mov	 dl, 10
  0000e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00012	48 03 cb	 add	 rcx, rbx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  0001b	0f b6 d0	 movzx	 edx, al
  0001e	48 8b cb	 mov	 rcx, rbx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 980  :     _Ostr.flush();

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 981  :     return _Ostr;

  00030	48 8b c3	 mov	 rax, rbx

; 982  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Ostr$ = 8
_Str$ = 16
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2319 :         return _BUF_SIZE <= _Myres;

  00000	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2305 :         const value_type* _Result = _Bx._Buf;

  00005	48 8b c2	 mov	 rax, rdx

; 2306 :         if (_Large_string_engaged()) {

  00008	72 03		 jb	 SHORT $LN6@operator

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0000a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN6@operator:

; 4983 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  0000d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00011	48 8b d0	 mov	 rdx, rax
  00014	e9 00 00 00 00	 jmp	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 734  :     const char* _Val) { // insert NTBS into char stream

$LN99:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	4c 8b fa	 mov	 r15, rdx
  00019	48 8b f1	 mov	 rsi, rcx

; 735  :     using _Elem = char;
; 736  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 737  : 
; 738  :     ios_base::iostate _State = ios_base::goodbit;

  0001c	33 db		 xor	 ebx, ebx
  0001e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	49 c7 c6 ff ff
	ff ff		 mov	 r14, -1
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL92@operator:
  00030	49 ff c6	 inc	 r14
  00033	42 38 1c 32	 cmp	 BYTE PTR [rdx+r14], bl
  00037	75 f7		 jne	 SHORT $LL92@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 363  :         return _Wide;

  00040	48 8b 7c 30 28	 mov	 rdi, QWORD PTR [rax+rsi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00045	48 85 ff	 test	 rdi, rdi
  00048	7e 0a		 jle	 SHORT $LN17@operator
  0004a	49 3b fe	 cmp	 rdi, r14
  0004d	7e 05		 jle	 SHORT $LN17@operator
  0004f	49 2b fe	 sub	 rdi, r14
  00052	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00054	33 ff		 xor	 edi, edi
$LN18@operator:

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00056	4c 8b e6	 mov	 r12, rsi
  00059	48 89 74 24 20	 mov	 QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  0005e	4c 8b 44 30 48	 mov	 r8, QWORD PTR [rax+rsi+72]
  00063	48 8b d1	 mov	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 73   :             if (_Rdbuf) {

  00066	4d 85 c0	 test	 r8, r8
  00069	74 0f		 je	 SHORT $LN39@operator

; 74   :                 _Rdbuf->_Lock();

  0006b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0006e	49 8b c8	 mov	 rcx, r8
  00071	ff 50 08	 call	 QWORD PTR [rax+8]
  00074	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00077	48 8b d1	 mov	 rdx, rcx
$LN39@operator:

; 93   :             if (!_Ostr.good()) {

  0007a	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0007e	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 93   :             if (!_Ostr.good()) {

  00083	74 04		 je	 SHORT $LN33@operator

; 94   :                 _Ok = false;

  00085	32 c0		 xor	 al, al

; 95   :                 return;

  00087	eb 2e		 jmp	 SHORT $LN95@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 70   :         return _Tiestr;

  00089	48 8b 44 30 50	 mov	 rax, QWORD PTR [rax+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0008e	48 85 c0	 test	 rax, rax
  00091	74 22		 je	 SHORT $LN35@operator
  00093	48 3b c6	 cmp	 rax, rsi
  00096	74 1d		 je	 SHORT $LN35@operator

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  :             _Tied->flush();

  00098	48 8b c8	 mov	 rcx, rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000a1	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000a4	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  000a8	83 7c 30 10 00	 cmp	 DWORD PTR [rax+rsi+16], 0
  000ad	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000b0	48 8b d1	 mov	 rdx, rcx
  000b3	eb 02		 jmp	 SHORT $LN95@operator
$LN35@operator:

; 100  :                 _Ok = true;

  000b5	b0 01		 mov	 al, 1
$LN95@operator:

; 106  :         }

  000b7	88 44 24 28	 mov	 BYTE PTR _Ok$[rsp+8], al

; 741  :     const typename _Myos::sentry _Ok(_Ostr);
; 742  : 
; 743  :     if (!_Ok) {

  000bb	84 c0		 test	 al, al
  000bd	75 0a		 jne	 SHORT $LN8@operator

; 744  :         _State |= ios_base::badbit;

  000bf	bb 04 00 00 00	 mov	 ebx, 4

; 745  :     } else { // state okay, insert

  000c4	e9 a9 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000c9	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 326  :         return _Fmtfl;

  000cd	8b 4c 30 18	 mov	 ecx, DWORD PTR [rax+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000d1	81 e1 c0 01 00
	00		 and	 ecx, 448		; 000001c0H
  000d7	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000da	74 2d		 je	 SHORT $LN87@operator
  000dc	0f 1f 40 00	 npad	 4
$LL4@operator:

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000e0	48 85 ff	 test	 rdi, rdi
  000e3	7e 21		 jle	 SHORT $LN89@operator

; 749  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000e5	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000e8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000ec	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000f1	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000fc	83 f8 ff	 cmp	 eax, -1
  000ff	74 48		 je	 SHORT $LN96@operator

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00101	48 ff cf	 dec	 rdi
  00104	eb da		 jmp	 SHORT $LL4@operator
$LN89@operator:

; 750  :                     _State |= ios_base::badbit; // insertion failed, quit
; 751  :                     break;
; 752  :                 }
; 753  :             }
; 754  :         }
; 755  : 
; 756  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00106	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN87@operator:
  00109	48 63 42 04	 movsxd	 rax, DWORD PTR [rdx+4]
  0010d	4d 8b c6	 mov	 r8, r14
  00110	49 8b d7	 mov	 rdx, r15
  00113	48 8b 4c 30 48	 mov	 rcx, QWORD PTR [rax+rsi+72]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  0011e	49 3b c6	 cmp	 rax, r14
  00121	75 26		 jne	 SHORT $LN96@operator
$LL93@operator:

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00123	48 85 ff	 test	 rdi, rdi
  00126	7e 2a		 jle	 SHORT $LN6@operator

; 762  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00128	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0012b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012f	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00134	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	74 05		 je	 SHORT $LN96@operator

; 757  :             _State |= ios_base::badbit;
; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {
; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00144	48 ff cf	 dec	 rdi
  00147	eb da		 jmp	 SHORT $LL93@operator
$LN96@operator:

; 763  :                     _State |= ios_base::badbit; // insertion failed, quit
; 764  :                     break;
; 765  :                 }
; 766  :             }
; 767  :         }
; 768  : 
; 769  :         _Ostr.width(0);

  00149	bb 04 00 00 00	 mov	 ebx, 4
  0014e	89 5c 24 70	 mov	 DWORD PTR _State$[rsp], ebx
$LN6@operator:
  00152	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00155	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00159	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream
  00162	eb 0e		 jmp	 SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios
  00164	48 8b 74 24 60	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00169	8b 5c 24 70	 mov	 ebx, DWORD PTR _State$[rsp]
  0016d	4c 8b 64 24 20	 mov	 r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 773  :     _Ostr.setstate(_State);

  00172	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00175	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00179	48 03 ce	 add	 rcx, rsi
  0017c	45 33 c0	 xor	 r8d, r8d
  0017f	8b d3		 mov	 edx, ebx
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00187	90		 npad	 1

; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00188	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0018d	84 c0		 test	 al, al
  0018f	75 0a		 jne	 SHORT $LN72@operator

; 119  :                 this->_Myostr._Osfx();

  00191	49 8b cc	 mov	 rcx, r12
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0019a	90		 npad	 1
$LN72@operator:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0019b	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0019f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ios

; 80   :         return _Mystrbuf;

  001a3	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\ostream

; 80   :             if (_Rdbuf) {

  001a8	48 85 c9	 test	 rcx, rcx
  001ab	74 07		 je	 SHORT $LN76@operator

; 81   :                 _Rdbuf->_Unlock();

  001ad	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b0	ff 50 10	 call	 QWORD PTR [rax+16]
  001b3	90		 npad	 1
$LN76@operator:

; 774  :     return _Ostr;

  001b4	48 8b c6	 mov	 rax, rsi

; 775  : }

  001b7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c0	41 5f		 pop	 r15
  001c2	41 5e		 pop	 r14
  001c4	41 5c		 pop	 r12
  001c6	5f		 pop	 rdi
  001c7	5e		 pop	 rsi
  001c8	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  0000d	48 8b 55 60	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00011	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00014	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	41 b0 01	 mov	 r8b, 1
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00029	90		 npad	 1
  0002a	48 b8 00 00 00
	00 00 00 00 00	 mov	 rax, 0
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
  0003a	cc		 int	 3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ PROC ; std::queue<int,std::deque<int,std::allocator<int> > >::~queue<int,std::deque<int,std::allocator<int> > >, COMDAT
  00000	e9 00 00 00 00	 jmp	 ??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >
??1?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ ENDP ; std::queue<int,std::deque<int,std::allocator<int> > >::~queue<int,std::deque<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
;	COMDAT ?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z PROC ; std::deque<int,std::allocator<int> >::_Growmap, COMDAT

; 1439 :     void _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2

$LN150:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1440 :         static_assert(1 < _Minimum_map_size, "The _Xlen() test should always be performed.");
; 1441 : 
; 1442 :         _Alpty _Almap(_Getal());
; 1443 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  00007	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  0000b	b8 01 00 00 00	 mov	 eax, 1
  00010	4d 85 c0	 test	 r8, r8
  00013	48 8b e9	 mov	 rbp, rcx
  00016	49 b9 ff ff ff
	ff ff ff ff 0f	 mov	 r9, 1152921504606846975	; 0fffffffffffffffH
  00020	49 0f 45 c0	 cmovne	 rax, r8
$LL2@Growmap:

; 1444 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _Minimum_map_size) {

  00024	48 8b f0	 mov	 rsi, rax
  00027	49 2b f0	 sub	 rsi, r8
  0002a	48 3b f2	 cmp	 rsi, rdx
  0002d	72 06		 jb	 SHORT $LN4@Growmap
  0002f	48 83 f8 08	 cmp	 rax, 8
  00033	73 14		 jae	 SHORT $LN3@Growmap
$LN4@Growmap:

; 1445 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1446 :             if (max_size() / _Block_size - _Newsize < _Newsize) {

  00035	49 8b c9	 mov	 rcx, r9
  00038	48 2b c8	 sub	 rcx, rax
  0003b	48 3b c8	 cmp	 rcx, rax
  0003e	0f 82 8c 01 00
	00		 jb	 $LN138@Growmap

; 1448 :             }
; 1449 : 
; 1450 :             _Newsize *= 2;

  00044	48 03 c0	 add	 rax, rax

; 1451 :         }

  00047	eb db		 jmp	 SHORT $LL2@Growmap
$LN3@Growmap:
  00049	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  0004e	48 b9 ff ff ff
	ff ff ff ff 1f	 mov	 rcx, 2305843009213693951 ; 1fffffffffffffffH
  00058	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1454 :         size_type _Myboff = _Myoff() / _Block_size;

  0005d	4c 8b 7d 18	 mov	 r15, QWORD PTR [rbp+24]
  00061	49 c1 ef 02	 shr	 r15, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 64   :         if (_Count > _Max_possible) {

  00065	48 3b c1	 cmp	 rax, rcx
  00068	0f 87 5c 01 00
	00		 ja	 $LN142@Growmap

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  0006e	48 8d 0c c5 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00076	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0007d	72 2c		 jb	 SHORT $LN19@Growmap

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0007f	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

  00083	48 3b c1	 cmp	 rax, rcx
  00086	0f 86 3e 01 00
	00		 jbe	 $LN142@Growmap

; 85   :         return ::operator new(_Bytes);

  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00094	48 85 c0	 test	 rax, rax
  00097	0f 84 26 01 00
	00		 je	 $LN130@Growmap

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0009d	4c 8d 70 27	 lea	 r14, QWORD PTR [rax+39]
  000a1	49 83 e6 e0	 and	 r14, -32		; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000a5	49 89 46 f8	 mov	 QWORD PTR [r14-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a9	eb 12		 jmp	 SHORT $LN18@Growmap
$LN19@Growmap:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  000ab	48 85 c9	 test	 rcx, rcx
  000ae	74 0a		 je	 SHORT $LN20@Growmap

; 85   :         return ::operator new(_Bytes);

  000b0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000b5	4c 8b f0	 mov	 r14, rax

; 244  :         return _Traits::_Allocate(_Bytes);

  000b8	eb 03		 jmp	 SHORT $LN18@Growmap
$LN20@Growmap:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  000ba	45 33 f6	 xor	 r14d, r14d
$LN18@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1458 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  000bd	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  000c1	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000c6	48 8b 5d 10	 mov	 rbx, QWORD PTR [rbp+16]
  000ca	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  000cf	48 c1 e3 03	 shl	 rbx, 3
  000d3	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000d8	4e 8d 24 fd 00
	00 00 00	 lea	 r12, QWORD PTR [r15*8]
  000e0	4a 8d 14 20	 lea	 rdx, QWORD PTR [rax+r12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000e4	48 2b da	 sub	 rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1456 :         _Mapptr _Myptr    = _Newmap + _Myboff;

  000e7	4b 8d 3c 34	 lea	 rdi, QWORD PTR [r12+r14]

; 1458 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  000eb	48 03 d8	 add	 rbx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ee	48 8b cf	 mov	 rcx, rdi
  000f1	4c 8b c3	 mov	 r8, rbx
  000f4	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1458 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  000f9	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  000fd	48 03 df	 add	 rbx, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1459 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

  00100	48 8b cb	 mov	 rcx, rbx
  00103	4c 3b fe	 cmp	 r15, rsi
  00106	77 25		 ja	 SHORT $LN6@Growmap
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00108	4d 8b c4	 mov	 r8, r12
  0010b	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00110	4c 8b c6	 mov	 r8, rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00113	49 8d 0c 1c	 lea	 rcx, QWORD PTR [r12+rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00117	4d 2b c7	 sub	 r8, r15
  0011a	33 d2		 xor	 edx, edx
  0011c	49 c1 e0 03	 shl	 r8, 3
  00120	e8 00 00 00 00	 call	 memset
  00125	4d 8b c4	 mov	 r8, r12
  00128	49 8b ce	 mov	 rcx, r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1463 :         } else { // increment not greater than offset of initial block

  0012b	eb 30		 jmp	 SHORT $LN147@Growmap
$LN6@Growmap:

; 1464 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

  0012d	48 8d 3c f5 00
	00 00 00	 lea	 rdi, QWORD PTR [rsi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00135	4c 8b c7	 mov	 r8, rdi
  00138	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1465 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  0013d	48 8b 5d 08	 mov	 rbx, QWORD PTR [rbp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00141	49 8b ce	 mov	 rcx, r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1465 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  00144	48 8d 14 1f	 lea	 rdx, QWORD PTR [rdi+rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4160 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00148	48 2b da	 sub	 rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1465 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  0014b	49 03 dc	 add	 rbx, r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xutility

; 4161 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0014e	4c 8b c3	 mov	 r8, rbx
  00151	e8 00 00 00 00	 call	 memmove

; 4163 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00156	4a 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0015a	4c 8b c7	 mov	 r8, rdi
$LN147@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1470 :         if (_Map() != _Mapptr()) {

  0015d	33 d2		 xor	 edx, edx
  0015f	e8 00 00 00 00	 call	 memset
  00164	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00168	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  0016d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00172	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00177	48 85 c9	 test	 rcx, rcx
  0017a	74 2e		 je	 SHORT $LN123@Growmap
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0017c	48 8b 55 10	 mov	 rdx, QWORD PTR [rbp+16]
  00180	48 c1 e2 03	 shl	 rdx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00184	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0018b	72 18		 jb	 SHORT $LN133@Growmap

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0018d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00191	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00195	49 2b c8	 sub	 rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00198	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0019c	48 83 f8 1f	 cmp	 rax, 31
  001a0	77 21		 ja	 SHORT $LN130@Growmap

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a2	49 8b c8	 mov	 rcx, r8
$LN133@Growmap:

; 264  :         ::operator delete(_Ptr, _Bytes);

  001a5	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN123@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1475 :         _Mapsize() += _Count;

  001aa	48 01 75 10	 add	 QWORD PTR [rbp+16], rsi
  001ae	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  001b3	4c 89 75 08	 mov	 QWORD PTR [rbp+8], r14
  001b7	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 1476 :     }

  001bc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001c0	5e		 pop	 rsi
  001c1	5d		 pop	 rbp
  001c2	c3		 ret	 0
$LN130@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001c9	cc		 int	 3
$LN142@Growmap:

; 138  :         _Throw_bad_array_new_length(); // add overflow

  001ca	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  001cf	cc		 int	 3
$LN138@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1447 :                 _Xlen(); // result too long

  001d0	48 8b cd	 mov	 rcx, rbp
  001d3	e8 00 00 00 00	 call	 ?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ ; std::deque<int,std::allocator<int> >::_Xlen
  001d8	cc		 int	 3
$LN146@Growmap:
?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z ENDP ; std::deque<int,std::allocator<int> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
;	COMDAT ?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ PROC	; std::deque<int,std::allocator<int> >::_Xlen, COMDAT

; 1431 :     [[noreturn]] void _Xlen() const {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1432 :         _Xlength_error("deque<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$deque@HV?$allocator@H@std@@@std@@AEBAXXZ ENDP	; std::deque<int,std::allocator<int> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
;	COMDAT ??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ PROC	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >, COMDAT

; 867  :     ~deque() noexcept {

$LN93:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 1009 :         return _Mysize() == 0;

  00012	33 f6		 xor	 esi, esi
  00014	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00018	48 85 c9	 test	 rcx, rcx

; 1482 :         while (!empty()) {

  0001b	74 17		 je	 SHORT $LN88@deque
  0001d	0f 1f 00	 npad	 3
$LL4@deque:

; 1153 :         if (--_Mysize() == 0) {

  00020	48 8d 41 ff	 lea	 rax, QWORD PTR [rcx-1]
  00024	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 85 c0	 test	 rax, rax
  0002e	75 f0		 jne	 SHORT $LL4@deque

; 1154 :             _Myoff() = 0;

  00030	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi
$LN88@deque:

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00034	48 8b 5f 10	 mov	 rbx, QWORD PTR [rdi+16]
  00038	48 85 db	 test	 rbx, rbx
  0003b	74 22		 je	 SHORT $LN7@deque
  0003d	0f 1f 00	 npad	 3
$LL6@deque:

; 1487 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  00040	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00044	48 ff cb	 dec	 rbx
  00047	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]
  0004b	48 85 c9	 test	 rcx, rcx
  0004e	74 0a		 je	 SHORT $LN25@deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00050	ba 10 00 00 00	 mov	 edx, 16
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN25@deque:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  0005a	48 85 db	 test	 rbx, rbx
  0005d	75 e1		 jne	 SHORT $LL6@deque
$LN7@deque:

; 1488 :                 _Getal().deallocate(_Map()[_Block], _Block_size);
; 1489 :                 _Destroy_in_place(_Map()[_Block]);
; 1490 :             }
; 1491 :         }
; 1492 : 
; 1493 :         if (_Map() != _Mapptr()) {

  0005f	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00063	48 85 c9	 test	 rcx, rcx
  00066	74 2e		 je	 SHORT $LN43@deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00068	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0006c	48 c1 e2 03	 shl	 rdx, 3

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00070	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00077	72 18		 jb	 SHORT $LN53@deque

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00079	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0007d	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00081	49 2b c8	 sub	 rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00084	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00088	48 83 f8 1f	 cmp	 rax, 31
  0008c	77 2f		 ja	 SHORT $LN50@deque

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0008e	49 8b c8	 mov	 rcx, r8
$LN53@deque:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00091	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN43@deque:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00096	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00099	ba 10 00 00 00	 mov	 edx, 16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0009e	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1497 :         _Mapsize() = 0;

  000a1	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 1498 :         _Map()     = _Mapptr();

  000a5	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 871  :     }

  000a9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ae	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5f		 pop	 rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  000b8	e9 00 00 00 00	 jmp	 ??3@YAXPEAX_K@Z		; operator delete
$LN50@deque:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000c3	cc		 int	 3
$LN90@deque:
??1?$deque@HV?$allocator@H@std@@@std@@QEAA@XZ ENDP	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
;	COMDAT ?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z
_TEXT	SEGMENT
i$1$ = 32
k$1$ = 40
$T1 = 48
tv665 = 56
text$GSCopy$1$ = 64
arr$GSCopy$1$ = 72
text$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 160
arr$ = 168
k$ = 176
text$ = 184
?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z PROC ; pattern_searcher_t::searchWords, COMDAT

; 138  : {

$LN75:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00023	4d 8b e9	 mov	 r13, r9
  00026	4c 89 4c 24 40	 mov	 QWORD PTR text$GSCopy$1$[rsp], r9
  0002b	41 8b f8	 mov	 edi, r8d
  0002e	44 89 44 24 28	 mov	 DWORD PTR k$1$[rsp], r8d
  00033	48 8b f2	 mov	 rsi, rdx
  00036	48 89 54 24 48	 mov	 QWORD PTR arr$GSCopy$1$[rsp], rdx
  0003b	4c 8b f1	 mov	 r14, rcx
  0003e	4c 89 4c 24 50	 mov	 QWORD PTR text$GSCopy$[rsp], r9

; 139  : 	// Preprocess patterns.
; 140  : 	// Build machine with goto, failure and output functions
; 141  : 	buildMatchingMachine(arr, k);

  00043	e8 00 00 00 00	 call	 ?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; pattern_searcher_t::buildMatchingMachine

; 142  : 
; 143  : 	// Initialize current state
; 144  : 	int currentState = 0;

  00048	45 33 ff	 xor	 r15d, r15d

; 145  : 
; 146  : 	// Traverse the text through the nuilt machine to find
; 147  : 	// all occurrences of words in arr[]
; 148  : 	for (int i = 0; i < text.size(); ++i)

  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	44 89 44 24 20	 mov	 DWORD PTR i$1$[rsp], r8d
  00053	4d 39 45 10	 cmp	 QWORD PTR [r13+16], r8
  00057	0f 86 72 01 00
	00		 jbe	 $LN3@searchWord
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 3843 :         return _Mypair._Myval2._Myptr()[_Off];

  0005d	33 c9		 xor	 ecx, ecx
  0005f	48 89 4c 24 30	 mov	 QWORD PTR $T1[rsp], rcx
  00064	33 ed		 xor	 ebp, ebp
  00066	33 c0		 xor	 eax, eax
  00068	48 89 44 24 38	 mov	 QWORD PTR tv665[rsp], rax
  0006d	0f 1f 00	 npad	 3
$LL4@searchWord:

; 2296 :         value_type* _Result = _Bx._Buf;

  00070	49 8b c5	 mov	 rax, r13

; 2297 :         if (_Large_string_engaged()) {

  00073	49 83 7d 18 10	 cmp	 QWORD PTR [r13+24], 16
  00078	72 04		 jb	 SHORT $LN15@searchWord

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0007a	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
$LN15@searchWord:
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 129  : 	while (g[answer][ch] == -1)

  0007e	48 0f be 14 01	 movsx	 rdx, BYTE PTR [rcx+rax]
  00083	48 83 ea 61	 sub	 rdx, 97			; 00000061H
  00087	48 69 c5 f4 01
	00 00		 imul	 rax, rbp, 500		; 000001f4H
  0008e	48 03 c2	 add	 rax, rdx
  00091	41 83 bc 86 a8
	0f 00 00 ff	 cmp	 DWORD PTR [r14+rax*4+4008], -1
  0009a	75 24		 jne	 SHORT $LN21@searchWord
  0009c	0f 1f 40 00	 npad	 4
$LL20@searchWord:

; 130  : 		answer = f[answer];

  000a0	4d 63 bc ae d8
	07 00 00	 movsxd	 r15, DWORD PTR [r14+rbp*4+2008]

; 129  : 	while (g[answer][ch] == -1)

  000a8	49 8b ef	 mov	 rbp, r15
  000ab	49 69 c7 f4 01
	00 00		 imul	 rax, r15, 500		; 000001f4H
  000b2	48 03 c2	 add	 rax, rdx
  000b5	41 83 bc 86 a8
	0f 00 00 ff	 cmp	 DWORD PTR [r14+rax*4+4008], -1
  000be	74 e0		 je	 SHORT $LL20@searchWord
$LN21@searchWord:

; 131  : 
; 132  : 	return g[answer][ch];

  000c0	49 63 c7	 movsxd	 rax, r15d
  000c3	48 69 c8 f4 01
	00 00		 imul	 rcx, rax, 500		; 000001f4H
  000ca	48 03 ca	 add	 rcx, rdx
  000cd	4d 63 bc 8e a8
	0f 00 00	 movsxd	 r15, DWORD PTR [r14+rcx*4+4008]

; 149  : 	{
; 150  : 		currentState = findNextState(currentState, text[i]);
; 151  : 
; 152  : 		// If match not found, move to next state
; 153  : 		if (out[currentState] == 0)

  000d5	49 8b ef	 mov	 rbp, r15
  000d8	43 83 7c be 08
	00		 cmp	 DWORD PTR [r14+r15*4+8], 0
  000de	0f 84 c4 00 00
	00		 je	 $LN2@searchWord

; 154  : 			continue;
; 155  : 
; 156  : 		// Match found, print all matching words of arr[]
; 157  : 		// using output function.
; 158  : 		for (int j = 0; j < k; ++j)

  000e4	85 ff		 test	 edi, edi
  000e6	0f 8e bc 00 00
	00		 jle	 $LN2@searchWord
  000ec	bb 01 00 00 00	 mov	 ebx, 1
  000f1	48 83 c6 10	 add	 rsi, 16
  000f5	44 8b e7	 mov	 r12d, edi
  000f8	44 8b 6c 24 20	 mov	 r13d, DWORD PTR i$1$[rsp]
  000fd	4c 8b 7c 24 38	 mov	 r15, QWORD PTR tv665[rsp]
$LL7@searchWord:

; 159  : 		{
; 160  : 			if (out[currentState] & (1 << j))

  00102	41 85 5c ae 08	 test	 ebx, DWORD PTR [r14+rbp*4+8]
  00107	74 79		 je	 SHORT $LN5@searchWord

; 162  : 				std::cout << "Word " << arr[j] << " appears from "

  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FPLIKJMG@Word?5@
  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00117	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  0011c	48 8d 56 f0	 lea	 rdx, QWORD PTR [rsi-16]

; 2306 :         if (_Large_string_engaged()) {

  00120	48 83 7e 08 10	 cmp	 QWORD PTR [rsi+8], 16
  00125	72 03		 jb	 SHORT $LN28@searchWord

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  00127	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN28@searchWord:

; 4983 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  0012a	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
  0012d	48 8b c8	 mov	 rcx, rax
  00130	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 162  : 				std::cout << "Word " << arr[j] << " appears from "

  00135	49 8b ff	 mov	 rdi, r15
  00138	48 2b 3e	 sub	 rdi, QWORD PTR [rsi]
  0013b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@OIGFIEEN@?5appears?5from?5@
  00142	48 8b c8	 mov	 rcx, rax
  00145	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	48 8d 57 01	 lea	 rdx, QWORD PTR [rdi+1]
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_K@Z
  00157	48 8b c8	 mov	 rcx, rax
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MKEOLIJC@?5to?5@
  00161	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00166	48 8b c8	 mov	 rcx, rax
  00169	41 8b d5	 mov	 edx, r13d
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00172	48 8b c8	 mov	 rcx, rax
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN5@searchWord:

; 154  : 			continue;
; 155  : 
; 156  : 		// Match found, print all matching words of arr[]
; 157  : 		// using output function.
; 158  : 		for (int j = 0; j < k; ++j)

  00182	d1 c3		 rol	 ebx, 1
  00184	48 83 c6 20	 add	 rsi, 32			; 00000020H
  00188	49 83 ec 01	 sub	 r12, 1
  0018c	0f 85 70 ff ff
	ff		 jne	 $LL7@searchWord
  00192	44 8b fd	 mov	 r15d, ebp
  00195	4c 8b 6c 24 40	 mov	 r13, QWORD PTR text$GSCopy$1$[rsp]
  0019a	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$1$[rsp]
  0019f	8b 7c 24 28	 mov	 edi, DWORD PTR k$1$[rsp]
  001a3	48 8b 74 24 48	 mov	 rsi, QWORD PTR arr$GSCopy$1$[rsp]
$LN2@searchWord:

; 145  : 
; 146  : 	// Traverse the text through the nuilt machine to find
; 147  : 	// all occurrences of words in arr[]
; 148  : 	for (int i = 0; i < text.size(); ++i)

  001a8	41 ff c0	 inc	 r8d
  001ab	44 89 44 24 20	 mov	 DWORD PTR i$1$[rsp], r8d
  001b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
  001b5	48 ff c1	 inc	 rcx
  001b8	48 89 4c 24 30	 mov	 QWORD PTR $T1[rsp], rcx
  001bd	49 63 c0	 movsxd	 rax, r8d
  001c0	48 89 44 24 38	 mov	 QWORD PTR tv665[rsp], rax
  001c5	49 3b 45 10	 cmp	 rax, QWORD PTR [r13+16]
  001c9	0f 82 a1 fe ff
	ff		 jb	 $LL4@searchWord
$LN3@searchWord:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 2319 :         return _BUF_SIZE <= _Myres;

  001cf	49 8b 55 18	 mov	 rdx, QWORD PTR [r13+24]
  001d3	48 83 fa 10	 cmp	 rdx, 16

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001d7	72 2d		 jb	 SHORT $LN44@searchWord

; 4619 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4620 :             auto& _Al          = _Getal();
; 4621 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001d9	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001dc	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001e0	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001e7	72 18		 jb	 SHORT $LN54@searchWord

; 155  :     _Bytes += _Non_user_size;

  001e9	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ed	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001f1	49 2b c8	 sub	 rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f4	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  001f8	48 83 f8 1f	 cmp	 rax, 31
  001fc	77 42		 ja	 SHORT $LN51@searchWord

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001fe	49 8b c8	 mov	 rcx, r8
$LN54@searchWord:

; 264  :         ::operator delete(_Ptr, _Bytes);

  00201	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN44@searchWord:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  00206	49 c7 45 10 00
	00 00 00	 mov	 QWORD PTR [r13+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0020e	49 c7 45 18 0f
	00 00 00	 mov	 QWORD PTR [r13+24], 15

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00216	41 c6 45 00 00	 mov	 BYTE PTR [r13], 0
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 167  : }

  0021b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00220	48 33 cc	 xor	 rcx, rsp
  00223	e8 00 00 00 00	 call	 __security_check_cookie
  00228	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  00230	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00234	41 5f		 pop	 r15
  00236	41 5e		 pop	 r14
  00238	41 5d		 pop	 r13
  0023a	41 5c		 pop	 r12
  0023c	5f		 pop	 rdi
  0023d	5e		 pop	 rsi
  0023e	5d		 pop	 rbp
  0023f	c3		 ret	 0
$LN51@searchWord:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00246	cc		 int	 3
$LN72@searchWord:
?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z ENDP ; pattern_searcher_t::searchWords
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
k$1$ = 40
$T1 = 48
tv665 = 56
text$GSCopy$1$ = 64
arr$GSCopy$1$ = 72
text$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 160
arr$ = 168
k$ = 176
text$ = 184
?dtor$0@?0??searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z@4HA PROC ; `pattern_searcher_t::searchWords'::`1'::dtor$0
  00000	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR text$GSCopy$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z@4HA ENDP ; `pattern_searcher_t::searchWords'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
k$1$ = 40
$T1 = 48
tv665 = 56
text$GSCopy$1$ = 64
arr$GSCopy$1$ = 72
text$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 160
arr$ = 168
k$ = 176
text$ = 184
?dtor$0@?0??searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z@4HA PROC ; `pattern_searcher_t::searchWords'::`1'::dtor$0
  00000	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR text$GSCopy$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z@4HA ENDP ; `pattern_searcher_t::searchWords'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
;	COMDAT ?findNextState@pattern_searcher_t@@AEAAHHD@Z
_TEXT	SEGMENT
this$ = 8
currentState$ = 16
nextInput$ = 24
?findNextState@pattern_searcher_t@@AEAAHHD@Z PROC	; pattern_searcher_t::findNextState, COMDAT

; 125  : 	int answer = currentState;
; 126  : 	int ch = nextInput - 'a';
; 127  : 
; 128  : 	// If goto is not defined, use failure function
; 129  : 	while (g[answer][ch] == -1)

  00000	4d 0f be d0	 movsx	 r10, r8b
  00004	4c 8b c9	 mov	 r9, rcx
  00007	48 63 c2	 movsxd	 rax, edx
  0000a	4c 69 c0 f4 01
	00 00		 imul	 r8, rax, 500		; 000001f4H
  00011	4d 03 c2	 add	 r8, r10
  00014	42 83 bc 81 24
	0e 00 00 ff	 cmp	 DWORD PTR [rcx+r8*4+3620], -1
  0001d	75 21		 jne	 SHORT $LN3@findNextSt
  0001f	90		 npad	 1
$LL2@findNextSt:

; 130  : 		answer = f[answer];

  00020	49 63 94 81 d8
	07 00 00	 movsxd	 rdx, DWORD PTR [r9+rax*4+2008]
  00028	48 69 ca f4 01
	00 00		 imul	 rcx, rdx, 500		; 000001f4H
  0002f	48 8b c2	 mov	 rax, rdx
  00032	49 03 ca	 add	 rcx, r10
  00035	41 83 bc 89 24
	0e 00 00 ff	 cmp	 DWORD PTR [r9+rcx*4+3620], -1
  0003e	74 e0		 je	 SHORT $LL2@findNextSt
$LN3@findNextSt:

; 131  : 
; 132  : 	return g[answer][ch];

  00040	48 63 c2	 movsxd	 rax, edx
  00043	48 69 c8 f4 01
	00 00		 imul	 rcx, rax, 500		; 000001f4H
  0004a	49 03 ca	 add	 rcx, r10
  0004d	41 8b 84 89 24
	0e 00 00	 mov	 eax, DWORD PTR [r9+rcx*4+3620]

; 133  : }

  00055	c3		 ret	 0
?findNextState@pattern_searcher_t@@AEAAHHD@Z ENDP	; pattern_searcher_t::findNextState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
;	COMDAT ?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
q$ = 32
this$ = 128
arr$ = 136
states$1$ = 144
k$ = 144
?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; pattern_searcher_t::buildMatchingMachine, COMDAT

; 15   : {

$LN327:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0001f	45 8b f0	 mov	 r14d, r8d
  00022	48 8b f2	 mov	 rsi, rdx
  00025	48 8b d9	 mov	 rbx, rcx

; 16   : 	// Initialize all values in output function as 0.
; 17   : 	memset(out, 0, sizeof out);

  00028	48 83 c1 08	 add	 rcx, 8
  0002c	33 d2		 xor	 edx, edx
  0002e	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  00034	e8 00 00 00 00	 call	 memset

; 18   : 
; 19   : 	// Initialize all values in goto function as -1.
; 20   : 	memset(g, -1, sizeof g);

  00039	4c 8d bb a8 0f
	00 00		 lea	 r15, QWORD PTR [rbx+4008]
  00040	ba ff ff ff ff	 mov	 edx, -1
  00045	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  0004b	49 8b cf	 mov	 rcx, r15
  0004e	e8 00 00 00 00	 call	 memset

; 21   : 
; 22   : 	// Initially, we just have the 0 state
; 23   : 	int states = 1;

  00053	41 bd 01 00 00
	00		 mov	 r13d, 1
  00059	44 89 6d 40	 mov	 DWORD PTR states$1$[rbp-80], r13d

; 16   : 	// Initialize all values in output function as 0.
; 17   : 	memset(out, 0, sizeof out);

  0005d	45 33 e4	 xor	 r12d, r12d
  00060	41 8b fc	 mov	 edi, r12d

; 24   : 
; 25   : 	// Construct values for goto function, i.e., fill g[][]
; 26   : 	// This is same as building a Trie for arr[]
; 27   : 	for (int i = 0; i < k; ++i)

  00063	45 85 f6	 test	 r14d, r14d
  00066	0f 8e 90 00 00
	00		 jle	 $LN3@buildMatch
  0006c	4c 8d 4e 10	 lea	 r9, QWORD PTR [rsi+16]
$LL4@buildMatch:

; 28   : 	{
; 29   : 		const std::string& word = arr[i];
; 30   : 		int currentState = 0;

  00070	41 8b cc	 mov	 ecx, r12d

; 31   : 
; 32   : 		// Insert all characters of current word in arr[]
; 33   : 		for (int j = 0; j < word.size(); ++j)

  00073	45 8b d4	 mov	 r10d, r12d
  00076	4d 8b dc	 mov	 r11, r12
  00079	49 39 09	 cmp	 QWORD PTR [r9], rcx
  0007c	76 5f		 jbe	 SHORT $LN316@buildMatch
  0007e	66 90		 npad	 2
$LL7@buildMatch:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 2305 :         const value_type* _Result = _Bx._Buf;

  00080	49 8d 41 f0	 lea	 rax, QWORD PTR [r9-16]

; 2306 :         if (_Large_string_engaged()) {

  00084	49 83 79 08 10	 cmp	 QWORD PTR [r9+8], 16
  00089	72 03		 jb	 SHORT $LN30@buildMatch

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN30@buildMatch:
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 35   : 			int ch = word[j] - 'a' /j; //TEST crash: integer divide by 0

  0008e	45 0f be 04 03	 movsx	 r8d, BYTE PTR [r11+rax]
  00093	b8 61 00 00 00	 mov	 eax, 97			; 00000061H
  00098	99		 cdq
  00099	41 f7 fa	 idiv	 r10d
  0009c	44 2b c0	 sub	 r8d, eax

; 36   : 
; 37   : 			// Allocate a new node (create a new state) if a
; 38   : 			// node for ch doesn't exist.
; 39   : 			if (g[currentState][ch] == -1)

  0009f	48 63 c1	 movsxd	 rax, ecx
  000a2	48 69 c8 f4 01
	00 00		 imul	 rcx, rax, 500		; 000001f4H
  000a9	49 63 c0	 movsxd	 rax, r8d
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8d 04 8b	 lea	 rax, QWORD PTR [rbx+rcx*4]
  000b3	8b 88 a8 0f 00
	00		 mov	 ecx, DWORD PTR [rax+4008]
  000b9	83 f9 ff	 cmp	 ecx, -1
  000bc	75 0d		 jne	 SHORT $LN317@buildMatch

; 40   : 				g[currentState][ch] = states++;

  000be	41 8b cd	 mov	 ecx, r13d
  000c1	44 89 a8 a8 0f
	00 00		 mov	 DWORD PTR [rax+4008], r13d
  000c8	41 ff c5	 inc	 r13d
$LN317@buildMatch:

; 31   : 
; 32   : 		// Insert all characters of current word in arr[]
; 33   : 		for (int j = 0; j < word.size(); ++j)

  000cb	41 ff c2	 inc	 r10d
  000ce	49 ff c3	 inc	 r11
  000d1	49 63 c2	 movsxd	 rax, r10d
  000d4	49 3b 01	 cmp	 rax, QWORD PTR [r9]
  000d7	72 a7		 jb	 SHORT $LL7@buildMatch
  000d9	44 89 6d 40	 mov	 DWORD PTR states$1$[rbp-80], r13d
$LN316@buildMatch:

; 41   : 
; 42   : 			currentState = g[currentState][ch];
; 43   : 		}
; 44   : 
; 45   : 		// Add current word in output function
; 46   : 		out[currentState] |= (1 << i);

  000dd	48 63 c1	 movsxd	 rax, ecx
  000e0	48 8d 0c 83	 lea	 rcx, QWORD PTR [rbx+rax*4]
  000e4	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  000e7	0f ab f8	 bts	 eax, edi
  000ea	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 24   : 
; 25   : 	// Construct values for goto function, i.e., fill g[][]
; 26   : 	// This is same as building a Trie for arr[]
; 27   : 	for (int i = 0; i < k; ++i)

  000ed	ff c7		 inc	 edi
  000ef	49 83 c1 20	 add	 r9, 32			; 00000020H
  000f3	41 3b fe	 cmp	 edi, r14d
  000f6	0f 8c 74 ff ff
	ff		 jl	 $LL4@buildMatch
$LN3@buildMatch:

; 47   : 	}
; 48   : 
; 49   : 	// For all characters which don't have an edge from
; 50   : 	// root (or state 0) in Trie, add a goto edge to state
; 51   : 	// 0 itself
; 52   : 	for (int ch = 0; ch < MAXC; ++ch)

  000fc	41 8b cc	 mov	 ecx, r12d
  000ff	39 4b 04	 cmp	 DWORD PTR [rbx+4], ecx
  00102	7e 16		 jle	 SHORT $LN9@buildMatch

; 40   : 				g[currentState][ch] = states++;

  00104	49 8b c7	 mov	 rax, r15
$LL10@buildMatch:

; 53   : 		if (g[0][ch] == -1)

  00107	83 38 ff	 cmp	 DWORD PTR [rax], -1
  0010a	75 03		 jne	 SHORT $LN8@buildMatch

; 54   : 			g[0][ch] = 0;

  0010c	44 89 20	 mov	 DWORD PTR [rax], r12d
$LN8@buildMatch:

; 47   : 	}
; 48   : 
; 49   : 	// For all characters which don't have an edge from
; 50   : 	// root (or state 0) in Trie, add a goto edge to state
; 51   : 	// 0 itself
; 52   : 	for (int ch = 0; ch < MAXC; ++ch)

  0010f	ff c1		 inc	 ecx
  00111	48 83 c0 04	 add	 rax, 4
  00115	3b 4b 04	 cmp	 ecx, DWORD PTR [rbx+4]
  00118	7c ed		 jl	 SHORT $LL10@buildMatch
$LN9@buildMatch:

; 55   : 
; 56   : 	// Now, let's build the failure function
; 57   : 
; 58   : 	// Initialize values in fail function
; 59   : 	memset(f, -1, sizeof f);

  0011a	48 8d 8b d8 07
	00 00		 lea	 rcx, QWORD PTR [rbx+2008]
  00121	ba ff ff ff ff	 mov	 edx, -1
  00126	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  0012c	e8 00 00 00 00	 call	 memset
  00131	90		 npad	 1
  00132	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 1089 :     _Container_proxy* _Myproxy = nullptr;

  00135	f3 0f 7f 45 d0	 movdqu	 XMMWORD PTR q$[rbp-80], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 561  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  0013a	4c 89 65 e0	 mov	 QWORD PTR q$[rbp-64], r12
  0013e	4c 89 65 e8	 mov	 QWORD PTR q$[rbp-56], r12
  00142	4c 89 65 f0	 mov	 QWORD PTR q$[rbp-48], r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00146	b9 10 00 00 00	 mov	 ecx, 16
  0014b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 1059 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00150	4c 89 60 08	 mov	 QWORD PTR [rax+8], r12

; 1076 :         _Myproxy            = _New_proxy;

  00154	48 89 45 d0	 mov	 QWORD PTR q$[rbp-80], rax

; 1077 :         _New_proxy->_Mycont = this;

  00158	48 8d 4d d0	 lea	 rcx, QWORD PTR q$[rbp-80]
  0015c	48 89 08	 mov	 QWORD PTR [rax], rcx
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 66   : 	for (int ch = 0; ch < MAXC; ++ch)

  0015f	45 8b f4	 mov	 r14d, r12d
  00162	4c 8b 45 f0	 mov	 r8, QWORD PTR q$[rbp-48]
  00166	44 39 63 04	 cmp	 DWORD PTR [rbx+4], r12d
  0016a	0f 8e c1 00 00
	00		 jle	 $LN278@buildMatch
$LL13@buildMatch:

; 67   : 	{
; 68   : 		// All nodes of depth 1 have failure function value
; 69   : 		// as 0. For example, in above diagram we move to 0
; 70   : 		// from states 1 and 3.
; 71   : 		if (g[0][ch] != 0)

  00170	49 63 07	 movsxd	 rax, DWORD PTR [r15]
  00173	85 c0		 test	 eax, eax
  00175	0f 84 a5 00 00
	00		 je	 $LN11@buildMatch

; 72   : 		{
; 73   : 			f[g[0][ch]] = 0;

  0017b	44 89 a4 83 d8
	07 00 00	 mov	 DWORD PTR [rbx+rax*4+2008], r12d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  00183	48 8b 4d e8	 mov	 rcx, QWORD PTR q$[rbp-56]
  00187	4c 8b 45 f0	 mov	 r8, QWORD PTR q$[rbp-48]
  0018b	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  0018f	48 8b 55 e0	 mov	 rdx, QWORD PTR q$[rbp-64]
  00193	a8 03		 test	 al, 3
  00195	75 27		 jne	 SHORT $LN86@buildMatch
  00197	49 8d 40 04	 lea	 rax, QWORD PTR [r8+4]
  0019b	48 c1 e8 02	 shr	 rax, 2
  0019f	48 3b d0	 cmp	 rdx, rax
  001a2	77 1a		 ja	 SHORT $LN86@buildMatch

; 1114 :             _Growmap(1);

  001a4	ba 01 00 00 00	 mov	 edx, 1
  001a9	48 8d 4d d0	 lea	 rcx, QWORD PTR q$[rbp-80]
  001ad	e8 00 00 00 00	 call	 ?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::deque<int,std::allocator<int> >::_Growmap

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  001b2	4c 8b 45 f0	 mov	 r8, QWORD PTR q$[rbp-48]
  001b6	48 8b 4d e8	 mov	 rcx, QWORD PTR q$[rbp-56]
  001ba	48 8b 55 e0	 mov	 rdx, QWORD PTR q$[rbp-64]
$LN86@buildMatch:

; 1115 :         }
; 1116 :         _Myoff() &= _Mapsize() * _Block_size - 1;

  001be	48 8d 04 95 ff
	ff ff ff	 lea	 rax, QWORD PTR [rdx*4-1]
  001c6	48 23 c8	 and	 rcx, rax
  001c9	48 89 4d e8	 mov	 QWORD PTR q$[rbp-56], rcx

; 1117 :         size_type _Newoff = _Myoff() + _Mysize();

  001cd	4a 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+r8]

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  001d1	48 8d 4a ff	 lea	 rcx, QWORD PTR [rdx-1]
  001d5	48 8b c7	 mov	 rax, rdi
  001d8	48 c1 e8 02	 shr	 rax, 2
  001dc	48 23 c8	 and	 rcx, rax

; 1119 :         if (_Map()[_Block] == nullptr) {

  001df	48 8d 34 cd 00
	00 00 00	 lea	 rsi, QWORD PTR [rcx*8]
  001e7	48 8b 4d d8	 mov	 rcx, QWORD PTR q$[rbp-72]
  001eb	48 83 3c 31 00	 cmp	 QWORD PTR [rcx+rsi], 0
  001f0	75 16		 jne	 SHORT $LN87@buildMatch
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 85   :         return ::operator new(_Bytes);

  001f2	b9 10 00 00 00	 mov	 ecx, 16
  001f7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1120 :             _Map()[_Block] = _Getal().allocate(_Block_size);

  001fc	48 8b 4d d8	 mov	 rcx, QWORD PTR q$[rbp-72]
  00200	48 89 04 31	 mov	 QWORD PTR [rcx+rsi], rax
  00204	48 8b 4d d8	 mov	 rcx, QWORD PTR q$[rbp-72]
$LN87@buildMatch:

; 1121 :         }
; 1122 : 
; 1123 :         _Alty_traits::construct(

  00208	83 e7 03	 and	 edi, 3
  0020b	48 8b 0c 31	 mov	 rcx, QWORD PTR [rcx+rsi]
  0020f	41 8b 07	 mov	 eax, DWORD PTR [r15]
  00212	89 04 b9	 mov	 DWORD PTR [rcx+rdi*4], eax

; 1124 :             _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), _STD forward<_Tys>(_Vals)...);
; 1125 : 
; 1126 :         ++_Mysize();

  00215	4c 8b 45 f0	 mov	 r8, QWORD PTR q$[rbp-48]
  00219	49 ff c0	 inc	 r8
  0021c	4c 89 45 f0	 mov	 QWORD PTR q$[rbp-48], r8
$LN11@buildMatch:
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 66   : 	for (int ch = 0; ch < MAXC; ++ch)

  00220	41 ff c6	 inc	 r14d
  00223	49 83 c7 04	 add	 r15, 4
  00227	44 3b 73 04	 cmp	 r14d, DWORD PTR [rbx+4]
  0022b	0f 8c 3f ff ff
	ff		 jl	 $LL13@buildMatch
$LN278@buildMatch:

; 74   : 			q.push(g[0][ch]);
; 75   : 		}
; 76   : 	}
; 77   : 
; 78   : 	// Now queue has states 1 and 3
; 79   : 	while (q.size())

  00231	4c 8b 4d e8	 mov	 r9, QWORD PTR q$[rbp-56]
  00235	4d 85 c0	 test	 r8, r8
  00238	0f 84 a4 01 00
	00		 je	 $LN15@buildMatch
  0023e	66 90		 npad	 2
$LL14@buildMatch:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  00240	48 8b 4d e0	 mov	 rcx, QWORD PTR q$[rbp-64]
  00244	48 ff c9	 dec	 rcx
  00247	49 8b c1	 mov	 rax, r9
  0024a	48 c1 e8 02	 shr	 rax, 2
  0024e	48 23 c8	 and	 rcx, rax
  00251	49 8b d1	 mov	 rdx, r9
  00254	83 e2 03	 and	 edx, 3

; 49   :         return _Mycont->_Map[_Block][_Off];

  00257	48 8b 45 d8	 mov	 rax, QWORD PTR q$[rbp-72]
  0025b	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 82   : 		int state = q.front();

  0025f	48 63 04 91	 movsxd	 rax, DWORD PTR [rcx+rdx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1102 :         if (--_Mysize() == 0) {

  00263	49 83 e8 01	 sub	 r8, 1
  00267	4c 89 45 f0	 mov	 QWORD PTR q$[rbp-48], r8
  0026b	75 09		 jne	 SHORT $LN141@buildMatch

; 1103 :             _Myoff() = 0;

  0026d	4d 8b cc	 mov	 r9, r12
  00270	4c 89 65 e8	 mov	 QWORD PTR q$[rbp-56], r12

; 1104 :         } else {

  00274	eb 07		 jmp	 SHORT $LN142@buildMatch
$LN141@buildMatch:

; 1105 :             ++_Myoff();

  00276	49 ff c1	 inc	 r9
  00279	4c 89 4d e8	 mov	 QWORD PTR q$[rbp-56], r9
$LN142@buildMatch:
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 88   : 		for (int ch = 0; ch <= MAXC; ++ch)

  0027d	33 ff		 xor	 edi, edi
  0027f	39 7b 04	 cmp	 DWORD PTR [rbx+4], edi
  00282	0f 8c 47 01 00
	00		 jl	 $LN319@buildMatch
  00288	4c 8b e8	 mov	 r13, rax
  0028b	48 69 c0 d0 07
	00 00		 imul	 rax, rax, 2000		; 000007d0H
  00292	4c 8d b3 a8 0f
	00 00		 lea	 r14, QWORD PTR [rbx+4008]
  00299	4c 03 f0	 add	 r14, rax
  0029c	0f 1f 40 00	 npad	 4
$LL18@buildMatch:

; 89   : 		{
; 90   : 			// If goto function is defined for character 'ch'
; 91   : 			// and 'state'
; 92   : 			if (g[state][ch] != -1)

  002a0	4d 63 16	 movsxd	 r10, DWORD PTR [r14]
  002a3	41 83 fa ff	 cmp	 r10d, -1
  002a7	0f 84 0e 01 00
	00		 je	 $LN16@buildMatch

; 93   : 			{
; 94   : 				// Find failure state of removed state
; 95   : 				int failure = f[state];

  002ad	4a 63 94 ab d8
	07 00 00	 movsxd	 rdx, DWORD PTR [rbx+r13*4+2008]

; 96   : 
; 97   : 				// Find the deepest node labeled by proper
; 98   : 				// suffix of string from root to current
; 99   : 				// state.
; 100  : 				while (g[failure][ch] == -1)

  002b5	48 8b ca	 mov	 rcx, rdx
  002b8	48 69 c2 f4 01
	00 00		 imul	 rax, rdx, 500		; 000001f4H
  002bf	48 03 c7	 add	 rax, rdi
  002c2	83 bc 83 a8 0f
	00 00 ff	 cmp	 DWORD PTR [rbx+rax*4+4008], -1
  002ca	75 23		 jne	 SHORT $LN20@buildMatch
  002cc	0f 1f 40 00	 npad	 4
$LL19@buildMatch:

; 101  : 					failure = f[failure];

  002d0	48 63 94 8b d8
	07 00 00	 movsxd	 rdx, DWORD PTR [rbx+rcx*4+2008]

; 96   : 
; 97   : 				// Find the deepest node labeled by proper
; 98   : 				// suffix of string from root to current
; 99   : 				// state.
; 100  : 				while (g[failure][ch] == -1)

  002d8	48 8b ca	 mov	 rcx, rdx
  002db	48 69 c2 f4 01
	00 00		 imul	 rax, rdx, 500		; 000001f4H
  002e2	48 03 c7	 add	 rax, rdi
  002e5	83 bc 83 a8 0f
	00 00 ff	 cmp	 DWORD PTR [rbx+rax*4+4008], -1
  002ed	74 e1		 je	 SHORT $LL19@buildMatch
$LN20@buildMatch:

; 102  : 
; 103  : 				failure = g[failure][ch];

  002ef	48 63 c2	 movsxd	 rax, edx
  002f2	48 69 c8 f4 01
	00 00		 imul	 rcx, rax, 500		; 000001f4H
  002f9	48 03 cf	 add	 rcx, rdi
  002fc	4c 63 84 8b a8
	0f 00 00	 movsxd	 r8, DWORD PTR [rbx+rcx*4+4008]

; 104  : 				f[g[state][ch]] = failure;

  00304	46 89 84 93 d8
	07 00 00	 mov	 DWORD PTR [rbx+r10*4+2008], r8d

; 105  : 
; 106  : 				// Merge output values
; 107  : 				out[g[state][ch]] |= out[failure];

  0030c	49 63 06	 movsxd	 rax, DWORD PTR [r14]
  0030f	48 8d 14 83	 lea	 rdx, QWORD PTR [rbx+rax*4]
  00313	42 8b 4c 83 08	 mov	 ecx, DWORD PTR [rbx+r8*4+8]
  00318	09 4a 08	 or	 DWORD PTR [rdx+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  0031b	48 8b 55 e8	 mov	 rdx, QWORD PTR q$[rbp-56]
  0031f	4c 8b 45 f0	 mov	 r8, QWORD PTR q$[rbp-48]
  00323	41 8d 04 10	 lea	 eax, DWORD PTR [r8+rdx]
  00327	48 8b 4d e0	 mov	 rcx, QWORD PTR q$[rbp-64]
  0032b	a8 03		 test	 al, 3
  0032d	75 27		 jne	 SHORT $LN153@buildMatch
  0032f	49 8d 40 04	 lea	 rax, QWORD PTR [r8+4]
  00333	48 c1 e8 02	 shr	 rax, 2
  00337	48 3b c8	 cmp	 rcx, rax
  0033a	77 1a		 ja	 SHORT $LN153@buildMatch

; 1114 :             _Growmap(1);

  0033c	ba 01 00 00 00	 mov	 edx, 1
  00341	48 8d 4d d0	 lea	 rcx, QWORD PTR q$[rbp-80]
  00345	e8 00 00 00 00	 call	 ?_Growmap@?$deque@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::deque<int,std::allocator<int> >::_Growmap

; 1113 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

  0034a	4c 8b 45 f0	 mov	 r8, QWORD PTR q$[rbp-48]
  0034e	48 8b 55 e8	 mov	 rdx, QWORD PTR q$[rbp-56]
  00352	48 8b 4d e0	 mov	 rcx, QWORD PTR q$[rbp-64]
$LN153@buildMatch:

; 1115 :         }
; 1116 :         _Myoff() &= _Mapsize() * _Block_size - 1;

  00356	48 8d 04 8d ff
	ff ff ff	 lea	 rax, QWORD PTR [rcx*4-1]
  0035e	48 23 d0	 and	 rdx, rax
  00361	48 89 55 e8	 mov	 QWORD PTR q$[rbp-56], rdx

; 1117 :         size_type _Newoff = _Myoff() + _Mysize();

  00365	4a 8d 34 02	 lea	 rsi, QWORD PTR [rdx+r8]

; 565  :         return (_Off / _Block_size) & (_Mapsize - 1);

  00369	48 ff c9	 dec	 rcx
  0036c	48 8b c6	 mov	 rax, rsi
  0036f	48 c1 e8 02	 shr	 rax, 2
  00373	48 23 c8	 and	 rcx, rax

; 1119 :         if (_Map()[_Block] == nullptr) {

  00376	4c 8d 3c cd 00
	00 00 00	 lea	 r15, QWORD PTR [rcx*8]
  0037e	48 8b 4d d8	 mov	 rcx, QWORD PTR q$[rbp-72]
  00382	4a 83 3c 39 00	 cmp	 QWORD PTR [rcx+r15], 0
  00387	75 16		 jne	 SHORT $LN154@buildMatch
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 85   :         return ::operator new(_Bytes);

  00389	b9 10 00 00 00	 mov	 ecx, 16
  0038e	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1120 :             _Map()[_Block] = _Getal().allocate(_Block_size);

  00393	48 8b 4d d8	 mov	 rcx, QWORD PTR q$[rbp-72]
  00397	4a 89 04 39	 mov	 QWORD PTR [rcx+r15], rax
  0039b	48 8b 4d d8	 mov	 rcx, QWORD PTR q$[rbp-72]
$LN154@buildMatch:

; 1121 :         }
; 1122 : 
; 1123 :         _Alty_traits::construct(

  0039f	83 e6 03	 and	 esi, 3
  003a2	4a 8b 0c 39	 mov	 rcx, QWORD PTR [rcx+r15]
  003a6	41 8b 06	 mov	 eax, DWORD PTR [r14]
  003a9	89 04 b1	 mov	 DWORD PTR [rcx+rsi*4], eax

; 1124 :             _Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size), _STD forward<_Tys>(_Vals)...);
; 1125 : 
; 1126 :         ++_Mysize();

  003ac	4c 8b 45 f0	 mov	 r8, QWORD PTR q$[rbp-48]
  003b0	49 ff c0	 inc	 r8
  003b3	4c 89 45 f0	 mov	 QWORD PTR q$[rbp-48], r8
  003b7	4c 8b 4d e8	 mov	 r9, QWORD PTR q$[rbp-56]
$LN16@buildMatch:
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 88   : 		for (int ch = 0; ch <= MAXC; ++ch)

  003bb	41 ff c4	 inc	 r12d
  003be	48 ff c7	 inc	 rdi
  003c1	49 83 c6 04	 add	 r14, 4
  003c5	44 3b 63 04	 cmp	 r12d, DWORD PTR [rbx+4]
  003c9	0f 8e d1 fe ff
	ff		 jle	 $LL18@buildMatch
$LN319@buildMatch:

; 74   : 			q.push(g[0][ch]);
; 75   : 		}
; 76   : 	}
; 77   : 
; 78   : 	// Now queue has states 1 and 3
; 79   : 	while (q.size())

  003cf	4d 85 c0	 test	 r8, r8
  003d2	41 bc 00 00 00
	00		 mov	 r12d, 0
  003d8	0f 85 62 fe ff
	ff		 jne	 $LL14@buildMatch
  003de	44 8b 6d 40	 mov	 r13d, DWORD PTR states$1$[rbp-80]
$LN15@buildMatch:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1009 :         return _Mysize() == 0;

  003e2	4d 85 c0	 test	 r8, r8

; 1482 :         while (!empty()) {

  003e5	74 1e		 je	 SHORT $LN196@buildMatch
  003e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL195@buildMatch:

; 1153 :         if (--_Mysize() == 0) {

  003f0	49 83 e8 01	 sub	 r8, 1
  003f4	4d 0f 44 cc	 cmove	 r9, r12

; 1009 :         return _Mysize() == 0;

  003f8	4d 85 c0	 test	 r8, r8

; 1482 :         while (!empty()) {

  003fb	75 f3		 jne	 SHORT $LL195@buildMatch

; 1153 :         if (--_Mysize() == 0) {

  003fd	4c 89 45 f0	 mov	 QWORD PTR q$[rbp-48], r8
  00401	4c 89 4d e8	 mov	 QWORD PTR q$[rbp-56], r9
$LN196@buildMatch:

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00405	48 8b 5d e0	 mov	 rbx, QWORD PTR q$[rbp-64]
  00409	48 85 db	 test	 rbx, rbx
  0040c	74 21		 je	 SHORT $LN198@buildMatch
  0040e	66 90		 npad	 2
$LL197@buildMatch:

; 1487 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  00410	48 ff cb	 dec	 rbx
  00413	48 8b 45 d8	 mov	 rax, QWORD PTR q$[rbp-72]
  00417	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]
  0041b	48 85 c9	 test	 rcx, rcx
  0041e	74 0a		 je	 SHORT $LN216@buildMatch
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00420	ba 10 00 00 00	 mov	 edx, 16
  00425	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN216@buildMatch:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1486 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  0042a	48 85 db	 test	 rbx, rbx
  0042d	75 e1		 jne	 SHORT $LL197@buildMatch
$LN198@buildMatch:

; 1488 :                 _Getal().deallocate(_Map()[_Block], _Block_size);
; 1489 :                 _Destroy_in_place(_Map()[_Block]);
; 1490 :             }
; 1491 :         }
; 1492 : 
; 1493 :         if (_Map() != _Mapptr()) {

  0042f	48 8b 4d d8	 mov	 rcx, QWORD PTR q$[rbp-72]
  00433	48 85 c9	 test	 rcx, rcx
  00436	74 39		 je	 SHORT $LN234@buildMatch
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00438	48 8b 45 e0	 mov	 rax, QWORD PTR q$[rbp-64]
  0043c	48 8d 14 c5 00
	00 00 00	 lea	 rdx, QWORD PTR [rax*8]
  00444	48 8b c1	 mov	 rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00447	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0044e	72 1c		 jb	 SHORT $LN244@buildMatch

; 155  :     _Bytes += _Non_user_size;

  00450	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00454	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00458	48 2b c1	 sub	 rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0045b	48 83 c0 f8	 add	 rax, -8
  0045f	48 83 f8 1f	 cmp	 rax, 31
  00463	76 07		 jbe	 SHORT $LN244@buildMatch
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0046b	cc		 int	 3
$LN244@buildMatch:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0046c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN234@buildMatch:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\deque

; 1497 :         _Mapsize() = 0;

  00471	4c 89 65 e0	 mov	 QWORD PTR q$[rbp-64], r12

; 1498 :         _Map()     = _Mapptr();

  00475	4c 89 65 d8	 mov	 QWORD PTR q$[rbp-72], r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00479	48 8b 4d d0	 mov	 rcx, QWORD PTR q$[rbp-80]

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0047d	4c 89 65 d0	 mov	 QWORD PTR q$[rbp-80], r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 264  :         ::operator delete(_Ptr, _Bytes);

  00481	ba 10 00 00 00	 mov	 edx, 16
  00486	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 115  : 	return states;

  0048b	41 8b c5	 mov	 eax, r13d

; 116  : }

  0048e	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00493	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00497	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  0049b	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  0049f	49 8b e3	 mov	 rsp, r11
  004a2	41 5f		 pop	 r15
  004a4	41 5e		 pop	 r14
  004a6	41 5d		 pop	 r13
  004a8	41 5c		 pop	 r12
  004aa	5d		 pop	 rbp
  004ab	c3		 ret	 0
$LN324@buildMatch:
?buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; pattern_searcher_t::buildMatchingMachine
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
q$ = 32
this$ = 128
arr$ = 136
states$1$ = 144
k$ = 144
?dtor$0@?0??buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA PROC ; `pattern_searcher_t::buildMatchingMachine'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR q$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0??buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA ENDP ; `pattern_searcher_t::buildMatchingMachine'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
q$ = 32
this$ = 128
arr$ = 136
states$1$ = 144
k$ = 144
?dtor$0@?0??buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA PROC ; `pattern_searcher_t::buildMatchingMachine'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR q$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$queue@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0??buildMatchingMachine@pattern_searcher_t@@AEAAHQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA ENDP ; `pattern_searcher_t::buildMatchingMachine'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp
;	COMDAT ?search@pattern_searcher_t@@QEAAHXZ
_TEXT	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?search@pattern_searcher_t@@QEAAHXZ PROC		; pattern_searcher_t::search, COMDAT

; 171  : {

$LN525:
  00000	40 55		 push	 rbp
  00002	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00007	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 45 47	 mov	 QWORD PTR __$ArrayPad$[rbp-169], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0001c	33 d2		 xor	 edx, edx
  0001e	48 89 55 c7	 mov	 QWORD PTR arr$[rbp-169], rdx

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00022	48 c7 45 df 0f
	00 00 00	 mov	 QWORD PTR arr$[rbp-145], 15

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0002a	48 c7 45 d7 02
	00 00 00	 mov	 QWORD PTR arr$[rbp-153], 2

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00032	b8 68 65 00 00	 mov	 eax, 25960		; 00006568H
  00037	66 89 45 c7	 mov	 WORD PTR arr$[rbp-169], ax

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003b	88 55 c9	 mov	 BYTE PTR arr$[rbp-167], dl

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0003e	48 89 55 e7	 mov	 QWORD PTR arr$[rbp-137], rdx

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  00042	48 c7 45 ff 0f
	00 00 00	 mov	 QWORD PTR arr$[rbp-113], 15

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0004a	48 c7 45 f7 03
	00 00 00	 mov	 QWORD PTR arr$[rbp-121], 3

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00052	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_03PJHPCKOL@she@
  00059	66 89 45 e7	 mov	 WORD PTR arr$[rbp-137], ax
  0005d	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_03PJHPCKOL@she@+2
  00064	88 45 e9	 mov	 BYTE PTR arr$[rbp-135], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00067	88 55 ea	 mov	 BYTE PTR arr$[rbp-134], dl

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0006a	48 89 55 07	 mov	 QWORD PTR arr$[rbp-105], rdx

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0006e	48 c7 45 1f 0f
	00 00 00	 mov	 QWORD PTR arr$[rbp-81], 15

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00076	48 c7 45 17 04
	00 00 00	 mov	 QWORD PTR arr$[rbp-89], 4

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0007e	c7 45 07 68 65
	72 73		 mov	 DWORD PTR arr$[rbp-105], 1936876904 ; 73726568H

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00085	88 55 0b	 mov	 BYTE PTR arr$[rbp-101], dl

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00088	48 89 55 27	 mov	 QWORD PTR arr$[rbp-73], rdx

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  0008c	48 c7 45 3f 0f
	00 00 00	 mov	 QWORD PTR arr$[rbp-49], 15

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  00094	48 c7 45 37 03
	00 00 00	 mov	 QWORD PTR arr$[rbp-57], 3

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0009c	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_03GDDNCFJF@his@
  000a3	66 89 45 27	 mov	 WORD PTR arr$[rbp-73], ax
  000a7	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_03GDDNCFJF@his@+2
  000ae	88 45 29	 mov	 BYTE PTR arr$[rbp-71], al

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000b1	88 55 2a	 mov	 BYTE PTR arr$[rbp-70], dl

; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000b4	48 c7 45 b7 0f
	00 00 00	 mov	 QWORD PTR text$[rbp-145], 15

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  000bc	48 c7 45 af 08
	00 00 00	 mov	 QWORD PTR text$[rbp-153], 8

; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000c4	48 b8 61 68 69
	73 68 65 72 73	 mov	 rax, 8318822960994019425 ; 7372656873696861H
  000ce	48 89 45 9f	 mov	 QWORD PTR text$[rbp-169], rax

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000d2	88 55 a7	 mov	 BYTE PTR text$[rbp-161], dl

; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d5	0f 10 45 9f	 movups	 xmm0, XMMWORD PTR text$[rbp-169]
  000d9	0f 11 44 24 20	 movups	 XMMWORD PTR $T1[rsp], xmm0
; File D:\dev\crashexplorer\crashexplorer\test_projects\test_project\static_library\pattern_searcher.cpp

; 176  : 	searchWords(arr, k, text);

  000de	48 c7 45 87 08
	00 00 00	 mov	 QWORD PTR $T1[rbp-153], 8
  000e6	48 c7 45 8f 0f
	00 00 00	 mov	 QWORD PTR $T1[rbp-145], 15
  000ee	4c 8d 4c 24 20	 lea	 r9, QWORD PTR $T1[rsp]
  000f3	44 8d 42 04	 lea	 r8d, QWORD PTR [rdx+4]
  000f7	48 8d 55 c7	 lea	 rdx, QWORD PTR arr$[rbp-169]
  000fb	e8 00 00 00 00	 call	 ?searchWords@pattern_searcher_t@@AEAAXQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV23@@Z ; pattern_searcher_t::searchWords
  00100	90		 npad	 1

; 177  : 
; 178  : 	return 0;

  00101	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00108	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0010d	44 8d 42 e4	 lea	 r8d, QWORD PTR [rdx-28]
  00111	48 8d 4d c7	 lea	 rcx, QWORD PTR arr$[rbp-169]
  00115	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  0011a	33 c0		 xor	 eax, eax

; 179  : }

  0011c	48 8b 4d 47	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-169]
  00120	48 33 cc	 xor	 rcx, rsp
  00123	e8 00 00 00 00	 call	 __security_check_cookie
  00128	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  0012f	5d		 pop	 rbp
  00130	c3		 ret	 0
?search@pattern_searcher_t@@QEAAHXZ ENDP		; pattern_searcher_t::search
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$0@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$0
  00000	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR arr$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$1@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$1
  00000	48 8d 8a 90 00
	00 00		 lea	 rcx, QWORD PTR arr$[rdx+32]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$2@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$2
  00000	48 8d 8a b0 00
	00 00		 lea	 rcx, QWORD PTR arr$[rdx+64]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	41 b8 04 00 00
	00		 mov	 r8d, 4
  00016	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0001b	48 8d 4d 70	 lea	 rcx, QWORD PTR arr$[rbp]
  0001f	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$4
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$5@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$5
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR text$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$0@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$0
  00000	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR arr$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$1@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$1
  00000	48 8d 8a 90 00
	00 00		 lea	 rcx, QWORD PTR arr$[rdx+32]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$2@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$2
  00000	48 8d 8a b0 00
	00 00		 lea	 rcx, QWORD PTR arr$[rdx+64]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	41 b8 04 00 00
	00		 mov	 r8d, 4
  00016	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0001b	48 8d 4d 70	 lea	 rcx, QWORD PTR arr$[rbp]
  0001f	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$4@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
text$ = 72
arr$ = 112
__$ArrayPad$ = 240
this$ = 272
?dtor$5@?0??search@pattern_searcher_t@@QEAAHXZ@4HA PROC	; `pattern_searcher_t::search'::`1'::dtor$5
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR text$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??search@pattern_searcher_t@@QEAAHXZ@4HA ENDP	; `pattern_searcher_t::search'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

$LN30:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2319 :         return _BUF_SIZE <= _Myres;

  00006	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  0000a	48 8b d9	 mov	 rbx, rcx

; 2319 :         return _BUF_SIZE <= _Myres;

  0000d	48 83 fa 10	 cmp	 rdx, 16

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00011	72 2c		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00016	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00020	72 18		 jb	 SHORT $LN22@basic_stri

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00026	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002a	49 2b c8	 sub	 rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002d	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00031	48 83 f8 1f	 cmp	 rax, 31
  00035	77 21		 ja	 SHORT $LN19@basic_stri

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00037	49 8b c8	 mov	 rcx, r8
$LN22@basic_stri:

; 264  :         ::operator delete(_Ptr, _Bytes);

  0003a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xstring

; 4633 :             _Mypair._Myval2._Mysize = 0;

  0003f	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00047	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004f	c6 03 00	 mov	 BYTE PTR [rbx], 0

; 3010 :     }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0005e	cc		 int	 3
$LN27@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 321  :     _THROW(bad_array_new_length{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
  0001f	cc		 int	 3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN12@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 67   :         _Data._What = _Message;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00007	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0
  0000f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 141  :     {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  0001a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 142  :     }

  0001d	48 8b c1	 mov	 rax, rcx
  00020	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN9@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 72   :     {

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 72   :     {

  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
  00030	48 89 03	 mov	 QWORD PTR [rbx], rax
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 90   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	e8 00 00 00 00	 call	 __std_exception_destroy
  00022	f6 c3 01	 test	 bl, 1
  00025	74 0d		 je	 SHORT $LN6@scalar
  00027	ba 18 00 00 00	 mov	 edx, 24
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN6@scalar:
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b c7	 mov	 rax, rdi
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	48 0f 45 c2	 cmovne	 rax, rdx

; 96   :     }

  00012	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	e9 00 00 00 00	 jmp	 __std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  0001a	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00021	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00024	e8 00 00 00 00	 call	 __std_exception_copy

; 74   :     }

  00029	48 8b c3	 mov	 rax, rbx
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
